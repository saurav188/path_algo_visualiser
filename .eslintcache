[{"C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\index.js":"1","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\App.js":"2","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\reportWebVitals.js":"3","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\components\\maze.js":"4","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\components\\maze_controls.js":"5","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\algorithms\\A_star.js":"6","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\algorithms\\BFS.js":"7","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\algorithms\\dijskra.js":"8","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\algorithms\\Genetic_algorithm.js":"9"},{"size":481,"mtime":1606826733164,"results":"10","hashOfConfig":"11"},{"size":317,"mtime":1618571839483,"results":"12","hashOfConfig":"11"},{"size":362,"mtime":499162500000,"results":"13","hashOfConfig":"11"},{"size":2411,"mtime":1618401693978,"results":"14","hashOfConfig":"11"},{"size":9895,"mtime":1618573226839,"results":"15","hashOfConfig":"11"},{"size":4897,"mtime":1618397699013,"results":"16","hashOfConfig":"11"},{"size":3421,"mtime":1618397725492,"results":"17","hashOfConfig":"11"},{"size":4189,"mtime":1618397733193,"results":"18","hashOfConfig":"11"},{"size":15810,"mtime":1618562300078,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"pses87",{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"22"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"32","messages":"33","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"22"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"22"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"22"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"22"},"C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\index.js",[],["44","45"],"C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\App.js",["46"],"C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\reportWebVitals.js",[],"C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\components\\maze.js",["47","48"],"import '../css/maze.css'\r\nimport React, { useState } from 'react';\r\n\r\nfunction Maze() {\r\n    var maze_width=window.innerWidth-10;\r\n    var maze_height=(0.8*window.innerHeight)-10;\r\n    var no_rows=Math.floor(maze_height/(25+(2*0.01)));\r\n    var no_columns=Math.floor(maze_width/(25+(2*0.01)));\r\n    var only_click=false;\r\n    var rows=new Array(no_rows).fill(true);\r\n    var columns=new Array(no_columns).fill(true);\r\n    const [clicked,change_clicked]=useState(false);\r\n    function build_maze(event){\r\n        if(document.getElementById('drawer').checked === true){\r\n            event.target.classList.add('obstacle')\r\n        }else if(document.getElementById('eraser').checked === true){\r\n            if(event.target.classList.contains('obstacle')){\r\n                event.target.classList.remove('obstacle')\r\n            };\r\n        }else if(document.getElementById('start').checked === true && only_click==true){\r\n            const grids=Array.from(document.getElementsByClassName('grid'));\r\n            grids.forEach(each=>{\r\n                if(each.classList.contains('start')){\r\n                    each.classList.remove('start');\r\n                };\r\n            });\r\n            event.target.classList.add('start');\r\n        }else if(document.getElementById('target').checked === true && only_click==true){\r\n            const grids=Array.from(document.getElementsByClassName('grid'));\r\n            grids.forEach(each=>{\r\n                if(each.classList.contains('target')){\r\n                    each.classList.remove('target');\r\n                };\r\n            });\r\n            event.target.classList.add('target');\r\n        };\r\n        only_click=false;\r\n    };\r\n    return (\r\n        <div className=\"maze\" style={{\r\n            maxWidth:{maze_width}+\"px\",\r\n            minWidth:{maze_width}+\"px\",\r\n            maxHeight:{maze_height}+\"px\",\r\n            minHeight:{maze_height}+\"px\"\r\n        }}>\r\n           {rows.map(()=>\r\n                <div className=\"maze_row\">\r\n                    {columns.map(()=>\r\n                        <div className='grid' \r\n                            onClick={event=>{change_clicked(!clicked);only_click=true;build_maze(event);}} \r\n                            onMouseOver={event=>{if(clicked){build_maze(event)}}}>\r\n                        </div>\r\n\r\n                    )}\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Maze;\r\n","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\components\\maze_controls.js",["49","50","51","52","53","54","55","56","57","58","59"],"C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\algorithms\\A_star.js",["60","61","62","63"],"function A_star(no_rows,no_columns){\r\n    const grids=Array.from(document.getElementsByClassName('grid'));\r\n    var tot_grids=grids.length;\r\n    var x,y;\r\n    var found_start=false;\r\n    var target=[]\r\n    var found_target=false;\r\n    var i=0;\r\n    grids.forEach(grid=>{\r\n        if(grid.classList.contains('start')){\r\n            y=Math.floor(i/no_columns)+1;\r\n            x=(i%no_columns)+1;\r\n            found_start=true;\r\n        }else if(grid.classList.contains('target')){\r\n            target.push((i%no_columns)+1);\r\n            target.push(Math.floor(i/no_columns)+1);\r\n            found_target=true;\r\n        };\r\n        i++;\r\n    });\r\n    if(!found_start || !found_target){\r\n        alert('choose target and start grid');\r\n        return\r\n    };\r\n    function get_neighbours(x,y,visited){\r\n        var neighbours=[];\r\n        var index=((y-1)*no_columns)+(x-1)\r\n        //top neighbour\r\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle') && visited[x+','+(y-1)]===undefined){\r\n            neighbours.push([x,(y-1)])\r\n        };\r\n        //right neighbour\r\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle') && visited[(x+1)+','+y]===undefined){\r\n            neighbours.push([(x+1),y])\r\n        };\r\n        //bottom neighbour\r\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle') && visited[x+','+(y+1)]===undefined){\r\n            neighbours.push([x,(y+1)])\r\n        };\r\n        //left neighbour\r\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle') && visited[(x-1)+','+y]===undefined){\r\n            neighbours.push([(x-1),y])\r\n        };\r\n        return neighbours;\r\n    };\r\n    function get_heuristic(current,target){\r\n        return  dist[current[0]+','+current[1]]+(Math.abs(target[0]-current[0]))+(Math.abs(target[1]-current[1]));\r\n    };\r\n    function sleep(milliseconds) {\r\n        const date = Date.now();\r\n        let currentDate = null;\r\n        do {\r\n          currentDate = Date.now();\r\n        } while (currentDate - date < milliseconds);\r\n      }\r\n    found_target=false;\r\n    var start=[x,y]\r\n    var open=[[x,y]];\r\n    var visited={};\r\n    var j=1;\r\n    var k=1;\r\n    var active_grids=[];\r\n    grids.forEach(grid=>{\r\n        if(!grid.classList.contains('obstacle')){\r\n            active_grids.push([j,k]);\r\n        };\r\n        if(j===no_columns){\r\n            k++;\r\n            j=1;\r\n        }else{\r\n            j++;\r\n        };\r\n    });\r\n    let dist={};\r\n    let parent={}\r\n    active_grids.forEach(each=>{\r\n        dist[each[0]+','+each[1]]=999999;\r\n    });\r\n    dist[x+','+y]=0;\r\n    var neighbours,winner,current,temp;\r\n    i=1;\r\n    var intervalId=null;\r\n    intervalId=setInterval(()=>{\r\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\r\n            clearInterval(intervalId);\r\n            return;\r\n        };\r\n        if(open.length<=0||found_target){clearInterval(intervalId);}\r\n        if(!found_target){\r\n            winner=0;\r\n            for(var i=0;i<open.length;i++){\r\n                if(get_heuristic(open[i],target)<get_heuristic(open[winner],target)){\r\n                    winner=i;\r\n                };\r\n            };\r\n            current=open[winner];\r\n            if(current[0]===target[0] && current[1]==target[1]){\r\n                found_target=true;\r\n                x=current[0];\r\n                y=current[1];\r\n                return\r\n            };\r\n            open.splice(winner,1);\r\n            visited[current[0]+','+current[1]]=true;\r\n            neighbours=get_neighbours(current[0],current[1],visited);\r\n            neighbours.forEach(neighbour=>{\r\n                if(dist[current[0]+','+current[1]]+1<dist[neighbour[0]+','+neighbour[1]]){\r\n                    dist[neighbour[0]+','+neighbour[1]]=dist[current[0]+','+current[1]]+1;\r\n                    parent[neighbour[0]+','+neighbour[1]]=[current[0],current[1]];\r\n                    if(!(neighbour in open)){\r\n                        open.push(neighbour)\r\n                    };\r\n                    if(!grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('start')\r\n                        && !grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('target')){\r\n                            grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.add('seen');\r\n                    };\r\n                };\r\n            });\r\n        }else{\r\n            while(!(x===start[0] && y===start[1])){\r\n            if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start') && \r\n                !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\r\n                    grids[((y-1)*no_columns)+(x-1)].classList.add('path');\r\n            };\r\n            temp=parent[x+','+y];\r\n            x=temp[0];\r\n            y=temp[1];\r\n        };\r\n        }\r\n    },25);\r\n};\r\n\r\nexport default A_star;","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\algorithms\\BFS.js",["64"],"export default function BFS(no_rows,no_columns){\r\n    const grids=Array.from(document.getElementsByClassName('grid'));\r\n    var x,y;\r\n    var found_start=false;\r\n    var target=[]\r\n    var found_target=false;\r\n    var i=0;\r\n    grids.forEach(grid=>{\r\n        if(grid.classList.contains('start')){\r\n            y=Math.floor(i/no_columns)+1;\r\n            x=(i%no_columns)+1;\r\n            found_start=true;\r\n        }else if(grid.classList.contains('target')){\r\n            target.push((i%no_columns)+1);\r\n            target.push(Math.floor(i/no_columns)+1);\r\n            found_target=true;\r\n        };\r\n        i++;\r\n    });\r\n    if(!found_start || !found_target){\r\n        alert('choose target and start grid');\r\n        return\r\n    };\r\n    function get_neighbours(x,y,visited){\r\n        var neighbours=[];\r\n        var index=((y-1)*no_columns)+(x-1);\r\n        visited[x+','+y]=true;\r\n        //top neighbour\r\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle') && visited[x+','+(y-1)]===undefined){\r\n            neighbours.push([x,(y-1)]);\r\n            visited[x+','+(y-1)]=true;\r\n        };\r\n        //right neighbour\r\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle') && visited[(x+1)+','+y]===undefined){\r\n            neighbours.push([(x+1),y]);\r\n            visited[(x+1)+','+y]=true;\r\n        };\r\n        //bottom neighbour\r\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle') && visited[x+','+(y+1)]===undefined){\r\n            neighbours.push([x,(y+1)]);\r\n            visited[x+','+(y+1)]=true;\r\n        };\r\n        //left neighbour\r\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle') && visited[(x-1)+','+y]===undefined){\r\n            neighbours.push([(x-1),y]);\r\n            visited[(x-1)+','+y]=true;\r\n        };\r\n        return neighbours;\r\n    };\r\n    var start=[x,y]\r\n    found_target=false;\r\n    var visited={};\r\n    var parent={};\r\n    var temp,neighbours;\r\n    var queue=[[x,y]];\r\n    var intervalId=null;\r\n    intervalId=setInterval(()=>{\r\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\r\n            clearInterval(intervalId);\r\n            return;\r\n        };\r\n        if(queue.length<=0 || found_target){clearInterval(intervalId);};\r\n        if(x===target[0] && y===target[1]){found_target=true;};\r\n        if(!found_target){\r\n            temp=queue.pop();\r\n            x=temp[0];\r\n            y=temp[1];\r\n            neighbours=get_neighbours(x,y,visited);\r\n            neighbours.forEach(neighbour=>{\r\n                queue.splice(0,0,neighbour);\r\n                parent[neighbour[0]+','+neighbour[1]]=[x,y]\r\n            });\r\n            if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start')\r\n                && !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\r\n                grids[((y-1)*no_columns)+(x-1)].classList.add('seen');\r\n            };\r\n        }else{\r\n            while(!(x===start[0] && y===start[1])){\r\n                if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start') && \r\n                    !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\r\n                        grids[((y-1)*no_columns)+(x-1)].classList.add('path');\r\n                };\r\n                temp=parent[x+','+y];\r\n                x=temp[0];\r\n                y=temp[1];\r\n            };\r\n        };\r\n    },25);\r\n};","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\algorithms\\dijskra.js",["65"],"export default function dijsktra(no_rows,no_columns){\r\n    const grids=Array.from(document.getElementsByClassName('grid'));\r\n    let x,y;\r\n    var found_start=false;\r\n    let target=[]\r\n    var found_target=false;\r\n    var i=0;\r\n    grids.forEach(grid=>{\r\n        if(grid.classList.contains('start')){\r\n            y=Math.floor(i/no_columns)+1;\r\n            x=(i%no_columns)+1;\r\n            found_start=true;\r\n        }else if(grid.classList.contains('target')){\r\n            target.push((i%no_columns)+1);\r\n            target.push(Math.floor(i/no_columns)+1);\r\n            found_target=true;\r\n        };\r\n        i++;\r\n    });\r\n    if(!found_start || !found_target){\r\n        alert('choose target and start grid');\r\n        return\r\n    };\r\n    function get_neighbours(x,y){\r\n        var neighbours=[];\r\n        var index=((y-1)*no_columns)+(x-1);\r\n        //top neighbour\r\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle')){\r\n            neighbours.push([x,(y-1)]);\r\n        };\r\n        //right neighbour\r\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle')){\r\n            neighbours.push([(x+1),y]);\r\n        };\r\n        //bottom neighbour\r\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle')){\r\n            neighbours.push([x,(y+1)]);\r\n        };\r\n        //left neighbour\r\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle')){\r\n            neighbours.push([(x-1),y]);\r\n        };\r\n        return neighbours;\r\n    };\r\n    var j=1;\r\n    var k=1;\r\n    var active_grids=[]\r\n    grids.forEach(grid=>{\r\n        if(!grid.classList.contains('obstacle')){\r\n            active_grids.push([j,k]);\r\n        };\r\n        if(j===no_columns){\r\n            k++;\r\n            j=1;\r\n        }else{\r\n            j++;\r\n        };\r\n    });\r\n    let dist={};\r\n    active_grids.forEach(each=>{\r\n        dist[each[0]+','+each[1]]=999999;\r\n    });\r\n    dist[x+','+y]=0;\r\n    var start=[x,y]\r\n    var parent={};\r\n    let neighbours,min\r\n    let current,z,temp;\r\n    var keep_looping=true;\r\n    var intervalId=null;\r\n    intervalId=setInterval(()=>{\r\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\r\n            clearInterval(intervalId);\r\n            return;\r\n        };\r\n        if(active_grids.length<=0 || !keep_looping){clearInterval(intervalId);}\r\n        min=99999;\r\n        for(var i=0;i<active_grids.length;i++){\r\n            temp=dist[active_grids[i][0]+','+active_grids[i][1]]\r\n            if(min>temp){\r\n                min=temp;\r\n                z=i;\r\n            };\r\n        };\r\n        current=active_grids[z];\r\n        active_grids.splice(z,1);\r\n        neighbours=get_neighbours(current[0],current[1]);\r\n        neighbours.forEach(neighbour=>{\r\n            if(dist[current[0]+','+current[1]]+1<dist[neighbour[0]+','+neighbour[1]]){\r\n                dist[neighbour[0]+','+neighbour[1]]=dist[current[0]+','+current[1]]+1;\r\n                parent[neighbour[0]+','+neighbour[1]]=[current[0],current[1]]\r\n            };\r\n            if(neighbour[0]===target[0] && neighbour[1]===target[1]){\r\n                x=neighbour[0];\r\n                y=neighbour[1];\r\n                keep_looping=false\r\n            };\r\n            if(!grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('start')\r\n                && !grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('target')){\r\n                    grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.add('seen');\r\n                    grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].innerHTML=dist[neighbour[0]+\",\"+neighbour[1]]\r\n            };\r\n        })\r\n        if(!keep_looping){\r\n            while(!(x===start[0] && y===start[1])){\r\n                if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start') && \r\n                    !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\r\n                        grids[((y-1)*no_columns)+(x-1)].classList.add('path');\r\n                };\r\n                temp=parent[x+','+y];\r\n                x=temp[0];\r\n                y=temp[1];\r\n            };\r\n        }\r\n    }, 25);\r\n};\r\n","C:\\Users\\Saurav\\Desktop\\git projects\\path_algo_visualiser\\src\\algorithms\\Genetic_algorithm.js",["66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82"],"import A_star from \"./A_star\";\r\n\r\nexport default function genetic_algorithm(no_rows,no_columns){\r\n    const grids=Array.from(document.getElementsByClassName('grid'));\r\n    var x,y;\r\n    var found_start=false;\r\n    var target=[]\r\n    var found_target=false;\r\n    var i=0;\r\n    grids.forEach(grid=>{\r\n        if(grid.classList.contains('start')){\r\n            y=Math.floor(i/no_columns)+1;\r\n            x=(i%no_columns)+1;\r\n            found_start=true;\r\n        }else if(grid.classList.contains('target')){\r\n            target.push((i%no_columns)+1);\r\n            target.push(Math.floor(i/no_columns)+1);\r\n            found_target=true;\r\n        };\r\n        i++;\r\n    });\r\n    if(!found_start || !found_target){\r\n        alert('choose target and start grid');\r\n        return\r\n    };\r\n    function get_neighbours(x,y,visited){\r\n        var neighbours=[];\r\n        var index=((y-1)*no_columns)+(x-1);\r\n        visited[x+','+y]=true;\r\n        //top neighbour\r\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle') && visited[x+','+(y-1)]===undefined){\r\n            neighbours.push([x,(y-1)]);\r\n            visited[x+','+(y-1)]=true;\r\n        };\r\n        //right neighbour\r\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle') && visited[(x+1)+','+y]===undefined){\r\n            neighbours.push([(x+1),y]);\r\n            visited[(x+1)+','+y]=true;\r\n        };\r\n        //bottom neighbour\r\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle') && visited[x+','+(y+1)]===undefined){\r\n            neighbours.push([x,(y+1)]);\r\n            visited[x+','+(y+1)]=true;\r\n        };\r\n        //left neighbour\r\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle') && visited[(x-1)+','+y]===undefined){\r\n            neighbours.push([(x-1),y]);\r\n            visited[(x-1)+','+y]=true;\r\n        };\r\n        return neighbours;\r\n    };\r\n    function getRndInteger(min, max) {\r\n        return Math.floor(Math.random() * (max - min) ) + min;\r\n    };\r\n    function dist(point1,point2){\r\n        var result=(((point2[0]-point1[0])^2)+((point2[1]-point1[1])^2))^(1/2);\r\n        if (result===0){\r\n            return 1;\r\n        }else{\r\n            return result;\r\n        };\r\n    };\r\n    function refresh(){\r\n        const grids=Array.from(document.getElementsByClassName('grid'));\r\n        grids.forEach(each=>{\r\n            if(each.classList.contains('path')){\r\n                each.classList.remove('path');\r\n            };\r\n        });\r\n    };\r\n    function display(max_fitness_path){\r\n        refresh();\r\n        max_fitness_path.forEach(each=>{\r\n            if(!grids[((each[1]-1)*no_columns)+(each[0]-1)].classList.contains('start') && \r\n                !grids[((each[1]-1)*no_columns)+(each[0]-1)].classList.contains('target')){\r\n                    grids[((each[1]-1)*no_columns)+(each[0]-1)].classList.add('path');\r\n            };\r\n        });\r\n    }\r\n    class path {\r\n        constructor(start,target){\r\n            var temp_path=[];\r\n            var temp=start;\r\n            var temp_visited={};\r\n            while(temp[0]!=target[0] || temp[1]!=target[1]){\r\n                var temp_neighbours=get_neighbours(temp[0],temp[1],temp_visited);\r\n                if(temp_neighbours.length===0){break};\r\n                var temp_next_index=getRndInteger(0,temp_neighbours.length);\r\n                var temp_next=temp_neighbours[temp_next_index];\r\n                temp_path.push(temp_next);\r\n                temp=temp_next;\r\n            };\r\n            var temp_fitness=25000;\r\n            if(temp[0]!==target[0] || temp[1]!==target[1]){temp_fitness=1000}\r\n            temp_fitness=temp_fitness/(temp_path.length^2);\r\n            this.path=temp_path;\r\n            this.fitness=Math.abs(temp_fitness);\r\n        };\r\n    };\r\n    function get_parent_according_to_prob(current_generation){\r\n        var i=Math.random()\r\n        var index=0\r\n        while(i>0){\r\n            i-=current_generation[index].prob;\r\n            index++;\r\n        };\r\n        return current_generation[index-1]\r\n    };\r\n    function get_fitness(path,target){\r\n        var temp_fitness=250000;\r\n        var temp=path[path.length-1]\r\n        if(temp[0]!==target[0] || temp[1]!==target[1]){temp_fitness=1000}\r\n        temp_fitness=temp_fitness/(path.length^2);\r\n        return Math.abs(temp_fitness);\r\n    };\r\n    function crossover(parent1,parent2,start,target){\r\n        var parent1_visited={};\r\n        var parent2_visited={};\r\n        var i=0;\r\n        var j=0;\r\n        var resulting_path=[];\r\n        var prev_i=0;\r\n        var prev_j=0;\r\n        var path1=parent1.path;\r\n        var path2=parent2.path;\r\n        var target_reached=false;\r\n        while(i<path1.length && j<path2.length){\r\n            parent1_visited[path1[i][0]+','+path1[i][1]]=i;\r\n            parent2_visited[path2[j][0]+','+path2[j][1]]=j;\r\n            if(parent1_visited[path2[j][0]+','+path2[j][1]]!==undefined){\r\n                resulting_path=resulting_path.concat(path1.slice(prev_i,parent1_visited[path2[j][0]+','+path2[j][1]]+1));\r\n                prev_i=parent1_visited[path2[j][0]+','+path2[j][1]]+1;\r\n                parent1_visited[path2[j][0]+','+path2[j][1]]=undefined;\r\n                prev_j=j+1;\r\n                i=prev_i;\r\n                j=prev_j;\r\n                if(j<path2.length){\r\n                    if(path2[j][0]===target[0] && path2[j][1]===target[1]){\r\n                        target_reached=true;\r\n                        break;\r\n                    };\r\n                };\r\n            }\r\n            else if(parent2_visited[path1[i][0]+','+path1[i][1]]!==undefined){\r\n                resulting_path=resulting_path.concat(path2.slice(prev_j,parent2_visited[path1[i][0]+','+path1[i][1]]+1));\r\n                prev_j=parent2_visited[path1[i][0]+','+path1[i][1]]+1;\r\n                parent2_visited[path1[i][0]+','+path1[i][1]]=undefined;\r\n                prev_i=i+1;\r\n                i=prev_i;\r\n                j=prev_j;\r\n                if(i<path1.length){\r\n                    if(path1[i][0]===target[0] && path1[i][1]===target[1]){\r\n                        target_reached=true;\r\n                        break;\r\n                    };\r\n                };\r\n            }\r\n            else if(path1[i][0]===target[0] && path1[i][1]===target[1]){\r\n                resulting_path=resulting_path.concat(path1.slice(prev_i,i+1));\r\n                target_reached=true;\r\n                break;\r\n            }\r\n            else if(path2[j][0]===target[0] && path2[j][1]===target[1]){\r\n                resulting_path=resulting_path.concat(path2.slice(prev_j,j+1));                \r\n                target_reached=true;\r\n                break;\r\n            }\r\n            else{\r\n                i+=1;\r\n                j+=1;\r\n            };\r\n        };\r\n        if(!target_reached){\r\n            if(i<path1.length){\r\n                resulting_path=resulting_path.concat(path1.slice(i,path1.length))\r\n            }else if(j<path2.length){\r\n                resulting_path=resulting_path.concat(path2.slice(j,path2.length))\r\n            };\r\n        };\r\n        var temp_child=new path(start,target)\r\n        temp_child.path=resulting_path;\r\n        temp_child.fitness=get_fitness(resulting_path,target);\r\n        return temp_child\r\n    };\r\n    function crossover2(parent1,parent2,start,target){\r\n        var parent1_visited={};\r\n        var parent2_visited={};\r\n        var i=0;\r\n        var j=0;\r\n        var resulting_path=[];\r\n        var path1=parent1.path;\r\n        var path2=parent2.path;\r\n        var both_reaches_target,parent1_reaches_target,parent2_reaches_target;\r\n        var crossover_complete=false;\r\n        while(i<path1.length && j<path2.length){\r\n            parent1_visited[path1[i][0]+','+path1[i][1]]=i;\r\n            parent2_visited[path2[j][0]+','+path2[j][1]]=j;\r\n            if(parent1_visited[path2[j][0]+','+path2[j][1]]!==undefined){\r\n                resulting_path=resulting_path.concat(path1.slice(0,parent1_visited[path2[j][0]+','+path2[j][1]]+1));\r\n                parent1_reaches_target=path1[path1.length-1][0]===target[0] && path1[path1.length-1][1]===target[1];\r\n                parent2_reaches_target=path2[path2.length-1][0]===target[0] && path2[path2.length-1][1]===target[1];\r\n                both_reaches_target=parent1_reaches_target && parent2_reaches_target;\r\n                if(both_reaches_target){\r\n                    if((path1.length-parent1_visited[path2[j][0]+','+path2[j][1]])<(path2.length-j)){\r\n                        resulting_path=resulting_path.concat(path1.slice(parent1_visited[path2[j][0]+','+path2[j][1]]+1,path1.length))\r\n                    }else{\r\n                        resulting_path=resulting_path.concat(path2.slice(j+1,path2.length))\r\n                    }\r\n                }\r\n                else if(parent1_reaches_target){\r\n                    resulting_path=resulting_path.concat(path1.slice(parent1_visited[path2[j][0]+','+path2[j][1]]+1,path1.length))\r\n                }\r\n                else if(parent2_reaches_target){\r\n                    resulting_path=resulting_path.concat(path2.slice(j+1,path2.length))\r\n                }\r\n                else{\r\n                    resulting_path=resulting_path.concat(path2.slice(j+1,path2.length))\r\n                };\r\n                crossover_complete=true;\r\n                break;\r\n            }\r\n            else if(parent2_visited[path1[i][0]+','+path1[i][1]]!==undefined){\r\n                resulting_path=resulting_path.concat(path2.slice(0,parent2_visited[path1[i][0]+','+path1[i][1]]+1));\r\n                parent1_reaches_target=path1[path1.length-1][0]===target[0] && path1[path1.length-1][1]===target[1];\r\n                parent2_reaches_target=path2[path2.length-1][0]===target[0] && path2[path2.length-1][1]===target[1];\r\n                both_reaches_target=parent1_reaches_target && parent2_reaches_target;\r\n                if(both_reaches_target){\r\n                    if((path2.length-parent2_visited[path1[i][0]+','+path1[i][1]])<(path1.length-i)){\r\n                        resulting_path=resulting_path.concat(path2.slice(parent2_visited[path1[i][0]+','+path1[i][1]]+1,path2.length))\r\n                    }else{\r\n                        resulting_path=resulting_path.concat(path1.slice(i+1,path1.length))\r\n                    }\r\n                }\r\n                else if(parent2_reaches_target){\r\n                    resulting_path=resulting_path.concat(path2.slice(parent2_visited[path1[i][0]+','+path1[i][1]]+1,path2.length))\r\n                }\r\n                else if(parent1_reaches_target){\r\n                    resulting_path=resulting_path.concat(path1.slice(i+1,path1.length))\r\n                }\r\n                else{\r\n                    resulting_path=resulting_path.concat(path1.slice(i+1,path1.length))\r\n                };\r\n                crossover_complete=true;\r\n                break;\r\n            }\r\n            else if(path1[i][0]===target[0] && path1[i][1]===target[1]){\r\n                resulting_path=resulting_path.concat(path1.slice(0,i+1));\r\n                crossover_complete=true;\r\n                break;\r\n            }\r\n            else if(path2[j][0]===target[0] && path2[j][1]===target[1]){\r\n                resulting_path=resulting_path.concat(path2.slice(0,j+1));\r\n                crossover_complete=true;\r\n                break;\r\n            }\r\n            else{\r\n                i+=1;\r\n                j+=1;\r\n            };\r\n        };\r\n        if(!crossover_complete){\r\n            resulting_path=path1;\r\n        }\r\n        var temp_child=new path(start,target)\r\n        temp_child.path=resulting_path;\r\n        temp_child.fitness=get_fitness(resulting_path,target)\r\n        return temp_child\r\n    };\r\n    function mutate(child,mutation_rate,start,target){\r\n        var random_no=Math.random();\r\n        if((random_no*100)-mutation_rate<0){\r\n            var temp_child=new path(start,target)\r\n            var temp_path=child.path\r\n            var random_index=getRndInteger(0,temp_path.length);\r\n            var temp_path=temp_path.slice(0,random_index);\r\n            var temp=child.path[random_index];\r\n            var temp_visited={};\r\n            var keep_original=false;\r\n            var target_reacher=child.path[child.path.length-1][0]===target[0] && child.path[child.path.length-1][1]===target[1];\r\n            if(target_reacher){\r\n                var random_index_two_steps_from_target=random_index+2<child.path.length;\r\n                if(random_index_two_steps_from_target){\r\n                    random_index=getRndInteger(random_index+1,child.path.length);\r\n                }else{\r\n                    random_index=child.path.length-1;\r\n                }\r\n                var temp_target=child.path[random_index];\r\n            }else{\r\n                var temp_target=target;\r\n            }\r\n            temp_path.forEach(each=>{\r\n                temp_visited[(each[0]+1)+','+each[1]]=true;\r\n            });\r\n            while(temp[0]!=temp_target[0] || temp[1]!=temp_target[1]){\r\n                temp_path.push(temp);\r\n                var temp_neighbours=get_neighbours(temp[0],temp[1],temp_visited);\r\n                if(temp_neighbours.length===0){\r\n                    keep_original=true;\r\n                    break\r\n                };\r\n                var temp_next_index=getRndInteger(0,temp_neighbours.length);\r\n                var temp_next=temp_neighbours[temp_next_index];\r\n                temp=temp_next;\r\n            };\r\n            temp_path.push(temp);\r\n            if(target_reacher){\r\n                temp_path=temp_path.concat(child.path.slice(random_index,child.path.length))\r\n            };\r\n            if(keep_original){\r\n                temp_path=child.path;\r\n            };\r\n            var temp_child=new path(start, target)\r\n            temp_child.path=temp_path;\r\n            temp_child.fitness=get_fitness(temp_path,target)\r\n            return temp_child\r\n        };\r\n        return child;\r\n    };\r\n    var start=[x,y]\r\n    var population=document.getElementById(\"genetic_algo_population\").value;\r\n    var mutation_rate=document.getElementById(\"genetic_algo_mutation_rate\").value;\r\n    if(population==\"\" || mutation_rate==\"\"){alert('Enter population and mutation rate');return}\r\n    var current_generation=[];\r\n    for(var i=0;i<population;i++){\r\n        current_generation.push(new path(start,target));\r\n    };\r\n    var genetic_algorithm_interval=setInterval(() => {\r\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\r\n            clearInterval(genetic_algorithm_interval);\r\n            refresh();\r\n            return;\r\n        };\r\n        var total_fitness=0;\r\n        var max_fitness=0;\r\n        var max_fitness_index;\r\n        for(var i=0;i<current_generation.length;i++){\r\n            if(current_generation[i].fitness>max_fitness){\r\n                max_fitness=current_generation[i].fitness;\r\n                max_fitness_index=i;\r\n            };\r\n            total_fitness+=current_generation[i].fitness;\r\n        };\r\n        var max_fitness_path=current_generation[max_fitness_index].path;\r\n        current_generation.forEach(each=>{\r\n            each.prob=each.fitness/total_fitness;\r\n        });\r\n        if(max_fitness==Infinity){\r\n            genetic_algorithm(no_rows,no_columns);\r\n            return;\r\n        };\r\n        display(max_fitness_path);\r\n        var temp_generation=[]\r\n        for(var i=0;i<population;i++){\r\n            var parent1=get_parent_according_to_prob(current_generation);\r\n            var parent2=get_parent_according_to_prob(current_generation);\r\n            var temp=crossover2(parent1,parent2,start,target);\r\n            var temp=mutate(temp,mutation_rate,start,target);\r\n            temp_generation.push(temp);\r\n        };\r\n        current_generation=temp_generation;\r\n    },10)\r\n};\r\n",{"ruleId":"83","replacedBy":"84"},{"ruleId":"85","replacedBy":"86"},{"ruleId":"87","severity":1,"message":"88","line":9,"column":11,"nodeType":"89","endLine":9,"endColumn":27},{"ruleId":"90","severity":1,"message":"91","line":20,"column":81,"nodeType":"92","messageId":"93","endLine":20,"endColumn":83},{"ruleId":"90","severity":1,"message":"91","line":28,"column":82,"nodeType":"92","messageId":"93","endLine":28,"endColumn":84},{"ruleId":"94","severity":1,"message":"95","line":7,"column":10,"nodeType":"96","messageId":"97","endLine":7,"endColumn":25},{"ruleId":"94","severity":1,"message":"98","line":8,"column":10,"nodeType":"96","messageId":"97","endLine":8,"endColumn":23},{"ruleId":"94","severity":1,"message":"99","line":9,"column":8,"nodeType":"96","messageId":"97","endLine":9,"endColumn":14},{"ruleId":"100","severity":1,"message":"101","line":42,"column":13,"nodeType":"96","messageId":"102","endLine":42,"endColumn":16},{"ruleId":"100","severity":1,"message":"103","line":43,"column":13,"nodeType":"96","messageId":"102","endLine":43,"endColumn":16},{"ruleId":"90","severity":1,"message":"91","line":139,"column":49,"nodeType":"92","messageId":"93","endLine":139,"endColumn":51},{"ruleId":"90","severity":1,"message":"91","line":164,"column":16,"nodeType":"92","messageId":"93","endLine":164,"endColumn":18},{"ruleId":"90","severity":1,"message":"91","line":165,"column":16,"nodeType":"92","messageId":"93","endLine":165,"endColumn":18},{"ruleId":"90","severity":1,"message":"91","line":166,"column":16,"nodeType":"92","messageId":"93","endLine":166,"endColumn":18},{"ruleId":"90","severity":1,"message":"91","line":167,"column":16,"nodeType":"92","messageId":"93","endLine":167,"endColumn":18},{"ruleId":"90","severity":1,"message":"91","line":173,"column":30,"nodeType":"92","messageId":"93","endLine":173,"endColumn":32},{"ruleId":"94","severity":1,"message":"104","line":3,"column":9,"nodeType":"96","messageId":"97","endLine":3,"endColumn":18},{"ruleId":"94","severity":1,"message":"105","line":49,"column":14,"nodeType":"96","messageId":"97","endLine":49,"endColumn":19},{"ruleId":"90","severity":1,"message":"91","line":84,"column":89,"nodeType":"92","messageId":"93","endLine":84,"endColumn":91},{"ruleId":"90","severity":1,"message":"91","line":97,"column":52,"nodeType":"92","messageId":"93","endLine":97,"endColumn":54},{"ruleId":"90","severity":1,"message":"91","line":58,"column":89,"nodeType":"92","messageId":"93","endLine":58,"endColumn":91},{"ruleId":"90","severity":1,"message":"91","line":71,"column":89,"nodeType":"92","messageId":"93","endLine":71,"endColumn":91},{"ruleId":"94","severity":1,"message":"106","line":1,"column":8,"nodeType":"96","messageId":"97","endLine":1,"endColumn":14},{"ruleId":"94","severity":1,"message":"107","line":55,"column":14,"nodeType":"96","messageId":"97","endLine":55,"endColumn":18},{"ruleId":"90","severity":1,"message":"108","line":85,"column":26,"nodeType":"92","messageId":"93","endLine":85,"endColumn":28},{"ruleId":"90","severity":1,"message":"108","line":85,"column":48,"nodeType":"92","messageId":"93","endLine":85,"endColumn":50},{"ruleId":"94","severity":1,"message":"109","line":116,"column":14,"nodeType":"96","messageId":"97","endLine":116,"endColumn":23},{"ruleId":"100","severity":1,"message":"110","line":275,"column":17,"nodeType":"96","messageId":"102","endLine":275,"endColumn":26},{"ruleId":"100","severity":1,"message":"111","line":289,"column":21,"nodeType":"96","messageId":"102","endLine":289,"endColumn":32},{"ruleId":"90","severity":1,"message":"108","line":294,"column":26,"nodeType":"92","messageId":"93","endLine":294,"endColumn":28},{"ruleId":"90","severity":1,"message":"108","line":294,"column":53,"nodeType":"92","messageId":"93","endLine":294,"endColumn":55},{"ruleId":"100","severity":1,"message":"112","line":312,"column":17,"nodeType":"96","messageId":"102","endLine":312,"endColumn":27},{"ruleId":"90","severity":1,"message":"91","line":322,"column":18,"nodeType":"92","messageId":"93","endLine":322,"endColumn":20},{"ruleId":"90","severity":1,"message":"91","line":322,"column":39,"nodeType":"92","messageId":"93","endLine":322,"endColumn":41},{"ruleId":"100","severity":1,"message":"113","line":324,"column":13,"nodeType":"96","messageId":"102","endLine":324,"endColumn":14},{"ruleId":"90","severity":1,"message":"91","line":328,"column":89,"nodeType":"92","messageId":"93","endLine":328,"endColumn":91},{"ruleId":"90","severity":1,"message":"91","line":347,"column":23,"nodeType":"92","messageId":"93","endLine":347,"endColumn":25},{"ruleId":"100","severity":1,"message":"113","line":353,"column":17,"nodeType":"96","messageId":"102","endLine":353,"endColumn":18},{"ruleId":"100","severity":1,"message":"114","line":357,"column":17,"nodeType":"96","messageId":"102","endLine":357,"endColumn":21},"no-native-reassign",["115"],"no-negated-in-lhs",["116"],"react/jsx-pascal-case","Imported JSX component Maze_control must be in PascalCase or SCREAMING_SNAKE_CASE","JSXOpeningElement","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'FontAwesomeIcon' is defined but never used.","Identifier","unusedVar","'faChevronDown' is defined but never used.","'Button' is defined but never used.","no-redeclare","'min' is already defined.","redeclared","'max' is already defined.","'tot_grids' is assigned a value but never used.","'sleep' is defined but never used.","'A_star' is defined but never used.","'dist' is defined but never used.","Expected '!==' and instead saw '!='.","'crossover' is defined but never used.","'temp_path' is already defined.","'temp_target' is already defined.","'temp_child' is already defined.","'i' is already defined.","'temp' is already defined.","no-global-assign","no-unsafe-negation"]