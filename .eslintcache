[{"/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/index.js":"1","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/App.js":"2","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/reportWebVitals.js":"3","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/components/user_manual.js":"4","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/components/maze.js":"5","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/components/maze_controls.js":"6","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/select_start.js":"7","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/maze_generator.js":"8","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/GA_options.js":"9","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/more_options.js":"10","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/maze_eraser.js":"11","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/select_algorithm.js":"12","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/maze_builder.js":"13","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/select_target.js":"14","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/start_stop_algo.js":"15","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/A_star.js":"16","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/BFS.js":"17","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/dijskra.js":"18","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/Genetic_algorithm.js":"19"},{"size":481,"mtime":1711949047672,"results":"20","hashOfConfig":"21"},{"size":713,"mtime":1711949047670,"results":"22","hashOfConfig":"21"},{"size":362,"mtime":1711949047672,"results":"23","hashOfConfig":"21"},{"size":3163,"mtime":1711949047671,"results":"24","hashOfConfig":"21"},{"size":2884,"mtime":1711949047670,"results":"25","hashOfConfig":"21"},{"size":9856,"mtime":1711949047670,"results":"26","hashOfConfig":"21"},{"size":630,"mtime":1711949047676,"results":"27","hashOfConfig":"21"},{"size":501,"mtime":1711949047676,"results":"28","hashOfConfig":"21"},{"size":731,"mtime":1711949047675,"results":"29","hashOfConfig":"21"},{"size":617,"mtime":1711949047676,"results":"30","hashOfConfig":"21"},{"size":924,"mtime":1711949047675,"results":"31","hashOfConfig":"21"},{"size":489,"mtime":1711949047676,"results":"32","hashOfConfig":"21"},{"size":864,"mtime":1711949047675,"results":"33","hashOfConfig":"21"},{"size":641,"mtime":1711949047676,"results":"34","hashOfConfig":"21"},{"size":742,"mtime":1711949047676,"results":"35","hashOfConfig":"21"},{"size":5386,"mtime":1711949047670,"results":"36","hashOfConfig":"21"},{"size":3789,"mtime":1711949047670,"results":"37","hashOfConfig":"21"},{"size":4666,"mtime":1711949047670,"results":"38","hashOfConfig":"21"},{"size":13319,"mtime":1711949047670,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"176c801",{"filePath":"42","messages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44"},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49"},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52"},{"filePath":"53","messages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55"},{"filePath":"56","messages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58"},{"filePath":"59","messages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61"},{"filePath":"62","messages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64"},{"filePath":"65","messages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67"},{"filePath":"68","messages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70"},{"filePath":"71","messages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73"},{"filePath":"74","messages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76"},{"filePath":"77","messages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79"},{"filePath":"80","messages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82"},{"filePath":"83","messages":"84","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"85"},{"filePath":"86","messages":"87","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"88"},{"filePath":"89","messages":"90","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"91"},{"filePath":"92","messages":"93","errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"94"},"/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/index.js",[],"/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/App.js",["95","96"],"import Maze from './components/maze.js'\nimport Maze_control from './components/maze_controls.js'\nimport User_Mannual from './components/user_manual.js'\nimport './css/index.css'\n\nfunction App() {\n    var maze_width=window.innerWidth-25;\n    var maze_height=(0.8*window.innerHeight)-25;\n    var no_rows=Math.floor(maze_height/(25+(2*0.01)));\n    var no_columns=Math.floor(maze_width/(25+(2*0.01)));\n    document.title=\"Path algo visualizer\";\n    return (\n        <div className=\"App\">\n          <Maze_control rows={no_rows} columns={no_columns} />\n          <Maze width={maze_width} height={maze_height} rows={no_rows} columns={no_columns} />\n          <User_Mannual />\n        </div>\n    );\n}\n\nexport default App;\n","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/reportWebVitals.js",[],"/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/components/user_manual.js",["97","98","99","100","101","102","103","104","105"],"import GA_options from \"../user_manual_components/GA_options.js\"\nimport Maze_builder from \"../user_manual_components/maze_builder.js\"\nimport Maze_eraser from \"../user_manual_components/maze_eraser.js\"\nimport Maze_generator from \"../user_manual_components/maze_generator.js\"\nimport More_options from \"../user_manual_components/more_options.js\"\nimport Select_algorithm from \"../user_manual_components/select_algorithm.js\"\nimport Select_start from \"../user_manual_components/select_start.js\"\nimport Select_target from \"../user_manual_components/select_target.js\"\nimport Start_stop_algo from \"../user_manual_components/start_stop_algo.js\"\nimport '../css/user_manual.css'\n\n/*\n    component containing user manual\n */\n\nexport default function User_manual(){\n    function show_mobile_manual(){\n        if(window.innerWidth<=720){\n            return <div className=\"no_show\"><More_options id=\"manual_6\" /></div>;\n        }\n        else{\n            return;\n        }\n    }\n    function next_clicked(){\n        var all_manuals=document.getElementsByClassName(\"all_manuals\")[0].children;\n        var to_show_index;\n        for(var i=0;i<all_manuals.length;i++){\n            if(all_manuals[i].classList.contains(\"show\")){\n                to_show_index=i+1;\n                all_manuals[i].classList.remove(\"show\");\n            };\n        };\n        if(to_show_index>all_manuals.length-1){skip();return;}\n        all_manuals[to_show_index].classList.add(\"show\");\n    };\n    function prev_clicked(){\n        var all_manuals=document.getElementsByClassName(\"all_manuals\")[0].children;\n        var to_show_index;\n        for(var i=0;i<all_manuals.length;i++){\n            if(all_manuals[i].classList.contains(\"show\")){\n                to_show_index=i-1;\n                all_manuals[i].classList.remove(\"show\");\n            };\n        };\n        if(to_show_index<0){to_show_index=0};\n        all_manuals[to_show_index].classList.add(\"show\");\n    };\n    function skip(){\n        document.getElementsByClassName(\"user_manual_main_container\")[0].classList.add(\"no_show\");\n    }\n    return (\n        <div className=\"user_manual_main_container\">\n            <button className=\"button prev\" onClick={prev_clicked}>Prev</button>\n            <button className=\"button next\" onClick={next_clicked}>Next</button>\n                <div className=\"all_manuals\">\n                    <div className=\"no_show show\"><Select_start id=\"manual_1\" /></div>\n                    <div className=\"no_show\"><Select_target id=\"manual_2\" /></div>\n                    <div className=\"no_show\"><Maze_builder id=\"manual_3\" /></div>\n                    <div className=\"no_show\"><Maze_eraser id=\"manual_4\" /></div>\n                    <div className=\"no_show\"><Maze_generator id=\"manual_5\" /></div>\n                    {show_mobile_manual()}\n                    <div className=\"no_show\"><Select_algorithm id=\"manual_7\" /></div>\n                    <div className=\"no_show\"><GA_options id=\"manual_8\" /></div>\n                    <div className=\"no_show\"><Start_stop_algo id=\"manual_9\" /></div>\n                </div>\n            <button className=\"button skip\" onClick={skip}>Skip</button>\n        </div>\n    );\n};","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/components/maze.js",["106","107"],"import '../css/maze.css'\nimport React, { useState,useEffect } from 'react';\n\n//Component: maze\n//\n//includes:\n//  onbstacles building function\n//  actual maze\n\nfunction Maze(props) {\n    var maze_width=props.width;\n    var maze_height=props.height;\n    var no_rows=props.rows;\n    var no_columns=props.columns;\n    var only_click=false;\n    var rows=new Array(no_rows).fill(true);\n    var columns=new Array(no_columns).fill(true);\n    const [clicked,change_clicked]=useState(false);\n    function check_for_obstacle_in_target(){\n        var target=Array.from(document.getElementsByClassName(\"target\"))[0];\n        target.classList.remove(\"obstacle\");\n    }\n    //obstacle_building_function\n    function build_maze(event){\n        if(document.getElementById('drawer').checked === true){\n            event.target.classList.add('obstacle')\n        }else if(document.getElementById('eraser').checked === true){\n            if(event.target.classList.contains('obstacle')){\n                event.target.classList.remove('obstacle')\n            };\n        }else if(document.getElementById('start').checked === true && only_click==true){\n            const grids=Array.from(document.getElementsByClassName('grid'));\n            grids.forEach(each=>{\n                if(each.classList.contains('start')){\n                    each.classList.remove('start');\n                };\n            });\n            event.target.classList.add('start');\n        }else if(document.getElementById('target').checked === true && only_click==true){\n            const grids=Array.from(document.getElementsByClassName('grid'));\n            grids.forEach(each=>{\n                if(each.classList.contains('target')){\n                    each.classList.remove('target');\n                };\n            });\n            event.target.classList.add('target');\n        };\n        only_click=false;\n        check_for_obstacle_in_target();\n    };\n    //adding start and target grid at the beginning\n    useEffect(()=>{\n            const grids=Array.from(document.querySelectorAll(\".grid\"));\n            grids[0].classList.add(\"start\");\n            grids[grids.length-1].classList.add(\"target\");\n    },[]);\n    \n    return (\n        <div className=\"maze\" style={{\n            maxWidth:{maze_width}+\"px\",\n            minWidth:{maze_width}+\"px\",\n            maxHeight:{maze_height}+\"px\",\n            minHeight:{maze_height}+\"px\"\n        }}>\n           {rows.map(()=>\n                <div className=\"maze_row\">\n                    {columns.map(()=>\n                        <div className='grid' \n                            onClick={event=>{change_clicked(!clicked);only_click=true;build_maze(event);}} \n                            onMouseOver={event=>{if(clicked){build_maze(event)}}}>\n                        </div>\n\n                    )}\n                </div>\n            )}\n        </div>\n    );\n};\n\nexport default Maze;\n","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/components/maze_controls.js",["108","109","110","111","112","113","114","115"],"import '../css/maze_control.css'\nimport A_star from '../algorithms/A_star'\nimport BFS from '../algorithms/BFS'\nimport dijkstra from '../algorithms/dijskra'\nimport genetic_algorithm from '../algorithms/Genetic_algorithm'\nimport { useState,useEffect } from 'react';\n\n\n// Component: maze controls\n// include:\n//   chooses maze building tools\n//   maze generating algo\n//   all other controls\n\nfunction Maze_control(props){\n    // uses the windows width and height to find no_rows and no_columns\n    var no_rows=props.rows;\n    var no_columns=props.columns;\n    function choose_eraser(){\n        document.getElementById('eraser').checked = true;\n        document.getElementById('drawer').checked = false;\n        document.getElementById('start').checked = false;\n        document.getElementById('target').checked = false;\n    };\n    function choose_drawer(){\n        document.getElementById('eraser').checked = false;\n        document.getElementById('drawer').checked = true;\n        document.getElementById('start').checked = false;\n        document.getElementById('target').checked = false;\n    };\n    function choose_start(){\n        document.getElementById('start').checked = true;\n        document.getElementById('target').checked = false;\n        document.getElementById('eraser').checked = false;\n        document.getElementById('drawer').checked = false;\n    };\n    function choose_target(){\n        document.getElementById('start').checked = false;\n        document.getElementById('target').checked = true;\n        document.getElementById('eraser').checked = false;\n        document.getElementById('drawer').checked = false;\n    };\n    // gets random interger in [min,max)\n    function getRandomInt(min, max) {\n        if(min===max){return min}\n        var min = Math.ceil(min);\n        var max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    //gives a random neighbour of a  grid for maze generating algo\n    function get_next(current,visited){\n        var neighbours=[];\n        var x=current[0]\n        var y=current[1]\n        visited[`${x},${y}`]=true;\n        //top neighbour\n        if(y>=3 && visited[`${x},${y-2}`]===undefined){\n            neighbours.push([x,(y-2)])\n        };\n        //right neighbour\n        if(x<=(no_columns-2) && visited[`${x+2},${y}`]===undefined){\n            neighbours.push([(x+2),y])\n        };\n        //bottom neighbour\n        if(y<=(no_rows-2) && visited[`${x},${y+2}`]===undefined){\n            neighbours.push([x,(y+2)])\n        };\n        //left neighbour\n        if(x>=3 && visited[`${x-2},${y}`]===undefined){\n            neighbours.push([(x-2),y])\n        };\n        var no_neighbours=neighbours.length;\n        if(no_neighbours===0){\n            return 0;\n        };\n        var result=neighbours[getRandomInt(1,no_neighbours)-1]\n        return result\n    };\n    // removes obstacle class from the target grid\n    function check_for_obstacle_in_target(){\n        var target=Array.from(document.getElementsByClassName(\"target\"))[0];\n        target.classList.remove(\"obstacle\");\n    }\n    // maze generating function\n    function maze_generator(e){\n        const grids=Array.from(document.getElementsByClassName('grid'));\n        refresh();\n        for(var i=0;i<grids.length;i++){\n            var y=Math.floor(i/no_columns)+1;\n            var x=(i%no_columns)+1;\n            if(x%2===0 || y%2===0){\n                grids[i].classList.add('obstacle');\n            };\n        };\n        var stack=[[1,1]];\n        var visited={}\n        var current=[1,1]\n        var intervarId=setInterval(()=>{\n            if(stack.length<=0){clearInterval(intervarId)}\n            var next=get_next(current,visited);\n            if(next===0){current=stack.pop();return};\n            var index=(((current[1]-1)*no_columns)+(current[0]-1))\n            //if current and next is in same row\n            if(current[1]===next[1]){\n                //left side\n                if(current[0]>next[0]){\n                        grids[index-1].classList.remove('obstacle');\n                }\n                //right side\n                else if(current[0]<next[0]){\n                    grids[index+1].classList.remove('obstacle');\n                };\n            }\n            //if current and next is in same column\n            else if(current[0]===next[0]){\n                //top\n                if(current[1]>next[1]){\n                    grids[index-no_columns].classList.remove('obstacle');\n                }\n                //bottom\n                else if(current[1]<next[1]){\n                    grids[index+no_columns].classList.remove('obstacle')\n                };\n            };\n            stack.push(next);\n            current=next;\n        },7.5);\n        check_for_obstacle_in_target();\n    };\n    // clears the maze for maze generation\n    function refresh(){\n        const grids=Array.from(document.getElementsByClassName('grid'));\n        grids.forEach(each=>{\n            if(each.classList.contains('obstacle')){\n                each.classList.remove('obstacle');\n            };\n            if(each.classList.contains('seen')){\n                each.classList.remove('seen');\n            };\n            if(each.classList.contains('path')){\n                each.classList.remove('path');\n            };\n        });\n    };\n    // stops any running algorithm and removes the path found\n    function stop_refresh(){\n        set_countinue_serching(continue_seaching==\"true\"?continue_seaching=\"false\":continue_seaching=\"true\");\n        const grids=Array.from(document.getElementsByClassName('grid'));\n        grids.forEach(each=>{\n            if(each.classList.contains('seen')){\n                each.classList.remove('seen');\n            };\n            if(each.classList.contains('path')){\n                each.classList.remove('path');\n            };\n            each.innerHTML=\"\";\n        });\n    };\n    var [continue_seaching,set_countinue_serching]=useState(\"false\");\n    // calls the algorithm choosen by the user\n    function find_path(){\n        stop_refresh();\n        set_countinue_serching(continue_seaching=\"true\");\n        var algo=document.getElementById('algorithm').value;\n        if(algo=='Genetic Algorithm'){genetic_algorithm(no_rows,no_columns);return}\n        if(algo=='A* algorithm'){A_star(no_rows,no_columns);return}\n        if(algo=='BFS'){BFS(no_rows,no_columns);return}\n        if(algo=='dijkstra'){dijkstra(no_rows,no_columns);return}\n    };\n    // shows more options when in mobile view\n    function show_more_options(){\n        var algo_choosing_div=document.querySelector(\".algo_choseing_div\");\n        var genetic_algo_options=document.querySelector(\".genetic_algo_options\");\n        var show_btn=document.querySelector('#show_btn');\n        if(show_btn.innerHTML==\"X\"){\n            algo_choosing_div.classList.remove(\"show_more_options1\");\n            genetic_algo_options.classList.remove(\"show_more_options2\");\n            show_btn.innerHTML=\"More\"\n        }\n        else{\n            algo_choosing_div.classList.add(\"show_more_options1\");\n            genetic_algo_options.classList.add(\"show_more_options2\");\n            show_btn.innerHTML=\"X\";\n        };\n        return\n    }\n    // adds population and mutation rate for genetic algorithm\n    useEffect(()=>{\n        document.getElementById(\"genetic_algo_population\").value=100;\n        document.getElementById(\"genetic_algo_mutation_rate\").value=10;\n    },[]);\n    return (\n        <div className=\"maze_control\">\n            <div class=\"maze_control_variables\">\n                <div id=\"maze_control_varaible_continue_searching\">{continue_seaching}</div>\n            </div>\n            <button class=\"show-btn\" onClick={()=>{show_more_options()}} id=\"show_btn\">More</button>\n            <button onClick={()=>stop_refresh()}> Stop </button><br></br>\n            <div className=\"algo_choseing_div\">\n                <h4 className=\"maze-building-title\">Algorithm:</h4>\n                <select id='algorithm'>\n                    <option value='A* algorithm'>A* algorithm</option>\n                    <option value='Genetic Algorithm'>Genetic Algorithm</option>\n                    <option value='BFS'>BFS</option>\n                    <option value='dijkstra'>dijkstra</option>\n                </select>\n            </div>\n            <br></br>\n            <div className=\"genetic_algo_options\">\n                <label for=\"genetic_algo_population\">Population: </label>\n                <input id=\"genetic_algo_population\" type=\"number\" min=\"10\"></input><br></br><br></br>\n                <label for=\"genetic_algo_mutation_rate\">Mutaion Rate: </label>\n                <input id=\"genetic_algo_mutation_rate\" type=\"number\" min=\"0\"></input><br></br>\n            </div>\n            <br></br>\n            <div className=\"algo-btns\">\n                <input type=\"checkbox\" id=\"start\" class=\"checkbox\" onClick={choose_start}></input>\n                <lable for=\"eraser\"> Start</lable><br></br>\n                <input type=\"checkbox\" id=\"target\" class=\"checkbox\" onClick={choose_target}></input>\n                <lable for=\"drawer\"> Target</lable><br></br>\n                <button id =\"find-path-btn\" onClick={()=>find_path()}>Find path</button>\n            </div>\n            <div className=\"maze_building_options\">\n                <h4 className=\"maze-building-title\">Maze building tools:</h4>\n                <input type=\"checkbox\" id=\"eraser\" class=\"checkbox\" onClick={choose_eraser}></input>\n                <lable for=\"eraser\"> Eraser</lable><br></br>\n                <input type=\"checkbox\" id=\"drawer\" class=\"checkbox\" onClick={choose_drawer}></input>\n                <lable for=\"drawer\"> Builder</lable><br></br>\n                <button class=\"btn generate-maze\" onClick={e=>maze_generator(e)}>Generate maze</button>\n            </div>\n        </div>\n    )\n};\n\nexport default Maze_control;\n\n","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/select_start.js",["116","117"],"import choose_start from  \"../user mannual  images/choose_start.PNG\"\nimport  build_start from \"../user mannual  images/build_start.PNG\"\nimport \"../css/user_manual.css\"\n//start selecting detail\n\nexport default function Select_start(){\n    return (\n        <div className=\"user_manual_container\">\n            <h3>Choose Start grid</h3>\n            <ul className=\"texts\">\n                <li>Select start in options.</li>\n                <li>Then choose the grid to be the start of the path.</li>\n            </ul>\n            <img src={choose_start}></img><br></br>\n            <img src={build_start}></img>\n        </div>\n    );\n};","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/maze_generator.js",["118"],"import choose_generate_maze from  \"../user mannual  images/choose_generate_maze.PNG\"\nimport \"../css/user_manual.css\"\n//maze generation detail\n\nexport default function Maze_generator(){\n    return (\n        <div className=\"user_manual_container\">\n            <h3>Auto Build Maze</h3>\n            <ul className=\"texts\">\n                <li>Click on the generate maze button to automatically built a maze.</li>\n            </ul>\n            <img src={choose_generate_maze}></img>\n        </div>\n    );\n};","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/GA_options.js",["119","120"],"import choose_mutation_rate from  \"../user mannual  images/choose_mutation_rate.PNG\"\nimport choose_population from  \"../user mannual  images/choose_population.PNG\"\nimport \"../css/user_manual.css\"\n//population and mutation rate control detail\n\nexport default function GA_options(){\n    return (\n        <div className=\"user_manual_container\">\n            <h3>Genetic Algorithm options</h3>\n            <ul className=\"texts\">\n                <li>If you choose Genetic Algorithms,you can customize by changing,</li>\n                <li>Mutation Rate.</li>\n                <li>Population.</li>\n            </ul>\n            <img src={choose_mutation_rate}></img>\n            <img src={choose_population}></img>\n        </div>\n    );\n};","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/more_options.js",["121","122"],"import choose_more from  \"../user mannual  images/mobile/choose_more.PNG\"\nimport optioons_open from  \"../user mannual  images/mobile/options_open.PNG\"\nimport \"../css/user_manual.css\"\n//more options detail\n\nexport default function More_options(){\n    return (\n        <div className=\"user_manual_container\">\n            <h3>More Options</h3>\n            <ul className=\"texts\">\n                <li>Click on More see more options.</li>\n                <li>Click on X close more options.</li>\n            </ul>\n            <img src={choose_more}></img>\n            <img src={optioons_open}></img>\n        </div>\n    );\n};","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/maze_eraser.js",["123","124","125","126"],"import choose_eraser from  \"../user mannual  images/choose_eraser.PNG\"\nimport  eraser1 from \"../user mannual  images/earser1.PNG\"\nimport  eraser2 from \"../user mannual  images/earser2.PNG\"\nimport  eraser3 from \"../user mannual  images/earser3.PNG\"\nimport \"../css/user_manual.css\"\n//maze eraser selection and erasing detail\n\nexport default function Maze_eraser(){\n    return (\n        <div className=\"user_manual_container\">\n            <h3>Erase Obstacles</h3>\n            <ul className=\"texts\">\n                <li>Select eraser in options.</li>\n                <li>Then click on the obstacle to erase.</li>\n                <li>Then hover around to erase more obstacle.</li>\n                <li>When done click again.</li>\n            </ul>\n            <img src={choose_eraser}></img>\n            <img src={eraser1}></img>\n            <img src={eraser2}></img>\n            <img src={eraser3}></img>\n        </div>\n    );\n};","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/select_algorithm.js",["127"],"import choose_algorithm from  \"../user mannual  images/choose_algorithm.PNG\"\nimport \"../css/user_manual.css\"\n//algorithm selection detail\n\nexport default function Select_algorithm(){\n    return (\n        <div className=\"user_manual_container\">\n            <h3>Select Algorithm</h3>\n            <ul className=\"texts\">\n                <li>Click on algorithm dropdown menu and choose an algorithm.</li>\n            </ul>\n            <img src={choose_algorithm}></img>\n        </div>\n    );\n};","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/maze_builder.js",["128","129","130"],"import choose_builder from  \"../user mannual  images/choose_builder.PNG\"\nimport  maze_build1 from \"../user mannual  images/maze_build1.PNG\"\nimport  maze_build2 from \"../user mannual  images/maze_build2.PNG\"\nimport \"../css/user_manual.css\"\n//maze buuilder selecting and building detail\n\nexport default function Maze_builder(){\n    return (\n        <div className=\"user_manual_container\">\n            <h3>Build Obstacles</h3>\n            <ul className=\"texts\">\n                <li>Select builder in options.</li>\n                <li>Then click on the grid to be a obstacle.</li>\n                <li>Then hover around to create more obstacle.</li>\n                <li>When done click again.</li>\n            </ul>\n            <img src={choose_builder}></img>\n            <img src={maze_build1}></img>\n            <img src={maze_build2}></img>\n        </div>\n    );\n};","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/select_target.js",["131","132"],"import choose_target from  \"../user mannual  images/Choose_target.PNG\"\nimport  build_target from \"../user mannual  images/build_target.PNG\"\nimport \"../css/user_manual.css\"\n//target selecting detail\n\nexport default function Select_target(){\n    return (\n        <div className=\"user_manual_container\">\n            <h3>Choose Target grid</h3>\n            <ul className=\"texts\">\n                <li>Select target in options.</li>\n                <li>Then choose the grid to be the target of the path.</li>\n            </ul>\n            <img src={choose_target}></img><br></br>\n            <img src={build_target}></img>\n        </div>\n    );\n};","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/user_manual_components/start_stop_algo.js",["133","134"],"import choose_start from  \"../user mannual  images/choose_start.PNG\"\nimport choose_stop from  \"../user mannual  images/choose_stop.PNG\"\nimport \"../css/user_manual.css\"\n//details on starting and stoping algorithm\n\nexport default function Start_stop_algo(){\n    return (\n        <div className=\"user_manual_container\">\n            <h3>Start and Stop the algorithm.</h3>\n            <ul className=\"texts\">\n                <li>Click on Find Path to run algorithm.</li>\n                <li>Click on Stop to stop algorithm.</li>\n                <li>***Always Stop the algorithm before starting another algorithm.***</li>\n            </ul>\n            <img src={choose_start}></img>\n            <img src={choose_stop}></img>\n        </div>\n    );\n};","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/A_star.js",["135","136"],"// A* path finding algorithm \n\nfunction A_star(no_rows,no_columns){\n    const grids=Array.from(document.getElementsByClassName('grid'));\n    var x,y;\n    var found_start=false;\n    var target=[]\n    var found_target=false;\n    var i=0;\n    // find target and start cooridinates\n    grids.forEach(grid=>{\n        if(grid.classList.contains('start')){\n            y=Math.floor(i/no_columns)+1;\n            x=(i%no_columns)+1;\n            found_start=true;\n        }else if(grid.classList.contains('target')){\n            target.push((i%no_columns)+1);\n            target.push(Math.floor(i/no_columns)+1);\n            found_target=true;\n        };\n        i++;\n    });\n    if(!found_start || !found_target){\n        alert('choose target and start grid');\n        return\n    };\n    //get all available neighbours of the given grid(x,y)\n    function get_neighbours(x,y,visited){\n        var neighbours=[];\n        var index=((y-1)*no_columns)+(x-1)\n        //top neighbour\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle') && visited[x+','+(y-1)]===undefined){\n            neighbours.push([x,(y-1)])\n        };\n        //right neighbour\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle') && visited[(x+1)+','+y]===undefined){\n            neighbours.push([(x+1),y])\n        };\n        //bottom neighbour\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle') && visited[x+','+(y+1)]===undefined){\n            neighbours.push([x,(y+1)])\n        };\n        //left neighbour\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle') && visited[(x-1)+','+y]===undefined){\n            neighbours.push([(x-1),y])\n        };\n        return neighbours;\n    };\n    // heuristic function for current\n    function get_heuristic(current,target){\n        return  dist[current[0]+','+current[1]]+(Math.abs(target[0]-current[0]))+(Math.abs(target[1]-current[1]));\n    };\n    found_target=false;\n    var start=[x,y]\n    var open=[[x,y]];\n    var visited={};\n    var j=1;\n    var k=1;\n    var active_grids=[];\n    //puts all the active grid to the array gids\n    grids.forEach(grid=>{\n        if(!grid.classList.contains('obstacle')){\n            active_grids.push([j,k]);\n        };\n        if(j===no_columns){\n            k++;\n            j=1;\n        }else{\n            j++;\n        };\n    });\n    let dist={};\n    let parent={}\n    //dist from start of all the grids is infinity \n    active_grids.forEach(each=>{\n        dist[each[0]+','+each[1]]=999999;\n    });\n    //dist of start from start is 0\n    dist[x+','+y]=0;\n    var neighbours,winner,current,temp;\n    i=1;\n    var intervalId=null;\n    intervalId=setInterval(()=>{\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\n            //stop the algorithm from running\n            clearInterval(intervalId);\n            return;\n        };\n        if(open.length<=0||found_target){clearInterval(intervalId);}\n        if(!found_target){\n            winner=0;\n            // chooses a winner with the least heuristic\n            for(var i=0;i<open.length;i++){\n                if(get_heuristic(open[i],target)<get_heuristic(open[winner],target)){\n                    winner=i;\n                };\n            };\n            current=open[winner];\n            //if cuurent is the target stop \n            if(current[0]===target[0] && current[1]==target[1]){\n                found_target=true;\n                x=current[0];\n                y=current[1];\n                return\n            };\n            //remove current from open array\n            open.splice(winner,1);\n            visited[current[0]+','+current[1]]=true;\n            neighbours=get_neighbours(current[0],current[1],visited);\n            neighbours.forEach(neighbour=>{\n                //finds if neighbour is reached yet \n                if(dist[current[0]+','+current[1]]+1<dist[neighbour[0]+','+neighbour[1]]){//this distance < Infinity if not visited\n                    //add nearest parent to neibour and new distance \n                    dist[neighbour[0]+','+neighbour[1]]=dist[current[0]+','+current[1]]+1;\n                    parent[neighbour[0]+','+neighbour[1]]=[current[0],current[1]];\n                    if(!(neighbour in open)){\n                        //add neighbout to open if its not in it yet\n                        open.push(neighbour)\n                    };\n                    //showt the grid as seen if the grid is not the start or the target\n                    if(!grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('start')\n                        && !grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('target')){\n                            grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.add('seen');\n                    };\n                };\n            });\n        }else{\n            //display the final path found\n            while(!(x===start[0] && y===start[1])){\n            if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start') && \n                !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\n                    grids[((y-1)*no_columns)+(x-1)].classList.add('path');\n            };\n            temp=parent[x+','+y];\n            x=temp[0];\n            y=temp[1];\n        };\n        }\n    },25);\n};\n\nexport default A_star;","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/BFS.js",["137"],"export default function BFS(no_rows,no_columns){\n    const grids=Array.from(document.getElementsByClassName('grid'));\n    var x,y;\n    var found_start=false;\n    var target=[]\n    var found_target=false;\n    var i=0;\n    //finds start and target grid\n    grids.forEach(grid=>{\n        if(grid.classList.contains('start')){\n            y=Math.floor(i/no_columns)+1;\n            x=(i%no_columns)+1;\n            found_start=true;\n        }else if(grid.classList.contains('target')){\n            target.push((i%no_columns)+1);\n            target.push(Math.floor(i/no_columns)+1);\n            found_target=true;\n        };\n        i++;\n    });\n    //checks if start and target grid is selected\n    if(!found_start || !found_target){\n        alert('choose target and start grid');\n        return\n    };\n    //gets all the non active ,non visited neighbours\n    function get_neighbours(x,y,visited){\n        var neighbours=[];\n        var index=((y-1)*no_columns)+(x-1);\n        visited[x+','+y]=true;\n        //top neighbour\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle') && visited[x+','+(y-1)]===undefined){\n            neighbours.push([x,(y-1)]);\n            visited[x+','+(y-1)]=true;\n        };\n        //right neighbour\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle') && visited[(x+1)+','+y]===undefined){\n            neighbours.push([(x+1),y]);\n            visited[(x+1)+','+y]=true;\n        };\n        //bottom neighbour\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle') && visited[x+','+(y+1)]===undefined){\n            neighbours.push([x,(y+1)]);\n            visited[x+','+(y+1)]=true;\n        };\n        //left neighbour\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle') && visited[(x-1)+','+y]===undefined){\n            neighbours.push([(x-1),y]);\n            visited[(x-1)+','+y]=true;\n        };\n        return neighbours;\n    };\n    var start=[x,y]\n    found_target=false;\n    var visited={};\n    var parent={};\n    var temp,neighbours;\n    var queue=[[x,y]];\n    var intervalId=null;\n    intervalId=setInterval(()=>{\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\n            //stop the algorithms when stop btn is clicked\n            clearInterval(intervalId);\n            return;\n        };\n        if(queue.length<=0 || found_target){clearInterval(intervalId);};\n        if(x===target[0] && y===target[1]){found_target=true;};\n        if(!found_target){//continue until target is found do this\n            //dequeue from the queue\n            temp=queue.pop();\n            x=temp[0];\n            y=temp[1];\n            neighbours=get_neighbours(x,y,visited);\n            //add nearest parent to the neighbour and add it to the queue\n            neighbours.forEach(neighbour=>{\n                queue.splice(0,0,neighbour);\n                parent[neighbour[0]+','+neighbour[1]]=[x,y]\n            });\n            //show the grid as seen if the grid is not the start or the target\n            if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start')\n                && !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\n                grids[((y-1)*no_columns)+(x-1)].classList.add('seen');\n            };\n        }else{// do this if target is found\n            while(!(x===start[0] && y===start[1])){\n                if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start') && \n                    !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\n                        grids[((y-1)*no_columns)+(x-1)].classList.add('path');\n                };\n                temp=parent[x+','+y];\n                x=temp[0];\n                y=temp[1];\n            };\n        };\n    },25);\n};","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/dijskra.js",["138"],"export default function dijsktra(no_rows,no_columns){\n    const grids=Array.from(document.getElementsByClassName('grid'));\n    let x,y;\n    var found_start=false;\n    let target=[]\n    var found_target=false;\n    var i=0;\n    //finds start and target grid\n    grids.forEach(grid=>{\n        if(grid.classList.contains('start')){\n            y=Math.floor(i/no_columns)+1;\n            x=(i%no_columns)+1;\n            found_start=true;\n        }else if(grid.classList.contains('target')){\n            target.push((i%no_columns)+1);\n            target.push(Math.floor(i/no_columns)+1);\n            found_target=true;\n        };\n        i++;\n    });\n    //checks if start and target grid is selected\n    if(!found_start || !found_target){\n        alert('choose target and start grid');\n        return\n    };\n    //gets all the non active ,non visited neighbours\n    //gets all the non active ,non visited neighbours\n    function get_neighbours(x,y){\n        var neighbours=[];\n        var index=((y-1)*no_columns)+(x-1);\n        //top neighbour\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle')){\n            neighbours.push([x,(y-1)]);\n        };\n        //right neighbour\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle')){\n            neighbours.push([(x+1),y]);\n        };\n        //bottom neighbour\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle')){\n            neighbours.push([x,(y+1)]);\n        };\n        //left neighbour\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle')){\n            neighbours.push([(x-1),y]);\n        };\n        return neighbours;\n    };\n    var j=1;\n    var k=1;\n    var active_grids=[]\n    //puts all the active grid to the array gids\n    grids.forEach(grid=>{\n        if(!grid.classList.contains('obstacle')){\n            active_grids.push([j,k]);\n        };\n        if(j===no_columns){\n            k++;\n            j=1;\n        }else{\n            j++;\n        };\n    });\n    let dist={};\n    //dist from start of all the grids is infinity \n    active_grids.forEach(each=>{\n        dist[each[0]+','+each[1]]=999999;\n    });\n    //dist of start from start is 0\n    dist[x+','+y]=0;\n    var start=[x,y]\n    var parent={};\n    let neighbours,min\n    let current,z,temp;\n    var keep_looping=true;\n    var intervalId=null;\n    intervalId=setInterval(()=>{\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\n            //stops the algorithm if stop btn is clicked\n            clearInterval(intervalId);\n            return;\n        };\n        if(active_grids.length<=0 || !keep_looping){clearInterval(intervalId);}\n        min=99999;\n        for(var i=0;i<active_grids.length;i++){\n            temp=dist[active_grids[i][0]+','+active_grids[i][1]]\n            if(min>temp){\n                min=temp;\n                z=i;\n            };\n        };\n        current=active_grids[z];\n        //removes current form active_grids\n        active_grids.splice(z,1);\n        neighbours=get_neighbours(current[0],current[1]);\n        neighbours.forEach(neighbour=>{\n            //adds best parent to the neighbour\n            if(dist[current[0]+','+current[1]]+1<dist[neighbour[0]+','+neighbour[1]]){\n                dist[neighbour[0]+','+neighbour[1]]=dist[current[0]+','+current[1]]+1;\n                parent[neighbour[0]+','+neighbour[1]]=[current[0],current[1]]\n            }\n            //checks if the the target is reached\n            if(neighbour[0]===target[0] && neighbour[1]===target[1]){\n                x=neighbour[0];\n                y=neighbour[1];\n                keep_looping=false\n            };\n            //shows the grid is visited\n            if(!grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('start')\n                && !grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('target')){\n                    grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.add('seen');\n                    grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].innerHTML=dist[neighbour[0]+\",\"+neighbour[1]]\n            };\n        })\n        if(!keep_looping){//display the final path \n            while(!(x===start[0] && y===start[1])){\n                if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start') && \n                    !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\n                        grids[((y-1)*no_columns)+(x-1)].classList.add('path');\n                };\n                temp=parent[x+','+y];\n                x=temp[0];\n                y=temp[1];\n            };\n        }\n    }, 25);\n};\n","/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/Genetic_algorithm.js",["139","140","141","142","143","144","145","146","147","148","149","150","151","152"],"export default function genetic_algorithm(no_rows,no_columns){\n    const grids=Array.from(document.getElementsByClassName('grid'));\n    var x,y;\n    var found_start=false;\n    var target=[]\n    var found_target=false;\n    var i=0;\n    //finds start and target\n    grids.forEach(grid=>{\n        if(grid.classList.contains('start')){\n            y=Math.floor(i/no_columns)+1;\n            x=(i%no_columns)+1;\n            found_start=true;\n        }else if(grid.classList.contains('target')){\n            target.push((i%no_columns)+1);\n            target.push(Math.floor(i/no_columns)+1);\n            found_target=true;\n        };\n        i++;\n    });\n    //checks if start and target is found\n    if(!found_start || !found_target){\n        alert('choose target and start grid');\n        return\n    };\n    //gets all the valid, non-visited neighbours\n    function get_neighbours(x,y,visited){\n        var neighbours=[];\n        var index=((y-1)*no_columns)+(x-1);\n        visited[x+','+y]=true;\n        //top neighbour\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle') && visited[x+','+(y-1)]===undefined){\n            neighbours.push([x,(y-1)]);\n            visited[x+','+(y-1)]=true;\n        };\n        //right neighbour\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle') && visited[(x+1)+','+y]===undefined){\n            neighbours.push([(x+1),y]);\n            visited[(x+1)+','+y]=true;\n        };\n        //bottom neighbour\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle') && visited[x+','+(y+1)]===undefined){\n            neighbours.push([x,(y+1)]);\n            visited[x+','+(y+1)]=true;\n        };\n        //left neighbour\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle') && visited[(x-1)+','+y]===undefined){\n            neighbours.push([(x-1),y]);\n            visited[(x-1)+','+y]=true;\n        };\n        return neighbours;\n    };\n    //random no x => min<=x<max\n    function getRndInteger(min, max) {\n        return Math.floor(Math.random() * (max - min) ) + min;\n    };\n    //removes the current path\n    function refresh(){\n        const grids=Array.from(document.getElementsByClassName('grid'));\n        grids.forEach(each=>{\n            if(each.classList.contains('path')){\n                each.classList.remove('path');\n            };\n        });\n    };\n    //dispalys the given path\n    function display(max_fitness_path){\n        refresh();\n        max_fitness_path.forEach(each=>{\n            if(!grids[((each[1]-1)*no_columns)+(each[0]-1)].classList.contains('start') && \n                !grids[((each[1]-1)*no_columns)+(each[0]-1)].classList.contains('target')){\n                    grids[((each[1]-1)*no_columns)+(each[0]-1)].classList.add('path');\n            };\n        });\n    }\n    //path class\n    class path {\n        //initialpath setup\n        constructor(start,target){\n            var temp_path=[];\n            var temp=start;\n            var temp_visited={};\n            //builds a path\n            while(temp[0]!=target[0] || temp[1]!=target[1]){\n                var temp_neighbours=get_neighbours(temp[0],temp[1],temp_visited);\n                if(temp_neighbours.length===0){break};\n                var temp_next_index=getRndInteger(0,temp_neighbours.length);\n                var temp_next=temp_neighbours[temp_next_index];\n                temp_path.push(temp_next);\n                temp=temp_next;\n            };\n            //adds fitness\n            var temp_fitness=25000;\n            if(temp[0]!==target[0] || temp[1]!==target[1]){temp_fitness=1000}\n            temp_fitness=temp_fitness/(temp_path.length^2);\n            this.path=temp_path;\n            this.fitness=Math.abs(temp_fitness);\n        };\n    };\n    //gets a random parent from the given generation according to probability\n    function get_parent_according_to_prob(current_generation){\n        var i=Math.random()\n        var index=0\n        //if probability of path i is 0.5 then it has 50% chance of chooseing\n        //because if i<0.5 then it is choosen and chance of i<0.5 is 50%\n        while(i>0){\n            i-=current_generation[index].prob;\n            index++;\n        };\n        return current_generation[index-1]\n    };\n    //gives fitness of the path with respect to the target\n    function get_fitness(path,target){\n        var temp_fitness=250000;\n        var temp=path[path.length-1]\n        if(temp[0]!==target[0] || temp[1]!==target[1]){temp_fitness=1000}\n        temp_fitness=temp_fitness/(path.length^2);\n        return Math.abs(temp_fitness);\n    };\n    //does crossover between to path gives a child path of these to path\n    function crossover2(parent1,parent2,start,target){\n        var parent1_visited={};\n        var parent2_visited={};\n        var i=0;\n        var j=0;\n        var resulting_path=[];\n        var path1=parent1.path;\n        var path2=parent2.path;\n        var both_reaches_target,parent1_reaches_target,parent2_reaches_target;\n        var crossover_complete=false;\n        //run the look until both paths grid can be read\n        while(i<path1.length && j<path2.length){\n            //save the index of the grids visited\n            parent1_visited[path1[i][0]+','+path1[i][1]]=i;\n            parent2_visited[path2[j][0]+','+path2[j][1]]=j;\n            //if the current path2 grid is already visited by path1\n            //the path till that grid is small for path1\n            if(parent1_visited[path2[j][0]+','+path2[j][1]]!==undefined){\n                resulting_path=resulting_path.concat(path1.slice(0,parent1_visited[path2[j][0]+','+path2[j][1]]+1));\n                parent1_reaches_target=path1[path1.length-1][0]===target[0] && path1[path1.length-1][1]===target[1];\n                parent2_reaches_target=path2[path2.length-1][0]===target[0] && path2[path2.length-1][1]===target[1];\n                both_reaches_target=parent1_reaches_target && parent2_reaches_target;\n                //if both reaches target \n                if(both_reaches_target){\n                    if((path1.length-parent1_visited[path2[j][0]+','+path2[j][1]])<(path2.length-j)){\n                        resulting_path=resulting_path.concat(path1.slice(parent1_visited[path2[j][0]+','+path2[j][1]]+1,path1.length))\n                    }else{\n                        resulting_path=resulting_path.concat(path2.slice(j+1,path2.length))\n                    }\n                }\n                else if(parent1_reaches_target){\n                    resulting_path=resulting_path.concat(path1.slice(parent1_visited[path2[j][0]+','+path2[j][1]]+1,path1.length))\n                }\n                else if(parent2_reaches_target){\n                    resulting_path=resulting_path.concat(path2.slice(j+1,path2.length))\n                }\n                else{\n                    resulting_path=resulting_path.concat(path2.slice(j+1,path2.length))\n                };\n                crossover_complete=true;\n                break;\n            }\n            else if(parent2_visited[path1[i][0]+','+path1[i][1]]!==undefined){\n                resulting_path=resulting_path.concat(path2.slice(0,parent2_visited[path1[i][0]+','+path1[i][1]]+1));\n                parent1_reaches_target=path1[path1.length-1][0]===target[0] && path1[path1.length-1][1]===target[1];\n                parent2_reaches_target=path2[path2.length-1][0]===target[0] && path2[path2.length-1][1]===target[1];\n                both_reaches_target=parent1_reaches_target && parent2_reaches_target;\n                if(both_reaches_target){\n                    if((path2.length-parent2_visited[path1[i][0]+','+path1[i][1]])<(path1.length-i)){\n                        resulting_path=resulting_path.concat(path2.slice(parent2_visited[path1[i][0]+','+path1[i][1]]+1,path2.length))\n                    }else{\n                        resulting_path=resulting_path.concat(path1.slice(i+1,path1.length))\n                    }\n                }\n                else if(parent2_reaches_target){\n                    resulting_path=resulting_path.concat(path2.slice(parent2_visited[path1[i][0]+','+path1[i][1]]+1,path2.length))\n                }\n                else if(parent1_reaches_target){\n                    resulting_path=resulting_path.concat(path1.slice(i+1,path1.length))\n                }\n                else{\n                    resulting_path=resulting_path.concat(path1.slice(i+1,path1.length))\n                };\n                crossover_complete=true;\n                break;\n            }\n            else if(path1[i][0]===target[0] && path1[i][1]===target[1]){\n                resulting_path=resulting_path.concat(path1.slice(0,i+1));\n                crossover_complete=true;\n                break;\n            }\n            else if(path2[j][0]===target[0] && path2[j][1]===target[1]){\n                resulting_path=resulting_path.concat(path2.slice(0,j+1));\n                crossover_complete=true;\n                break;\n            }\n            else{\n                i+=1;\n                j+=1;\n            };\n        };\n        if(!crossover_complete){\n            resulting_path=path1;\n        }\n        var temp_child=new path(start,target)\n        temp_child.path=resulting_path;\n        temp_child.fitness=get_fitness(resulting_path,target)\n        return temp_child\n    };\n    //mutates the given path\n    function mutate(child,mutation_rate,start,target){\n        var random_no=Math.random();\n        if((random_no*100)-mutation_rate<0){\n            var temp_child=new path(start,target)\n            var temp_path=child.path\n            var random_index=getRndInteger(0,temp_path.length);\n            var temp_path=temp_path.slice(0,random_index);\n            var temp=child.path[random_index];\n            var temp_visited={};\n            var keep_original=false;\n            var target_reacher=child.path[child.path.length-1][0]===target[0] && child.path[child.path.length-1][1]===target[1];\n            if(target_reacher){\n                var random_index_two_steps_from_target=random_index+2<child.path.length;\n                if(random_index_two_steps_from_target){\n                    random_index=getRndInteger(random_index+1,child.path.length);\n                }else{\n                    random_index=child.path.length-1;\n                }\n                var temp_target=child.path[random_index];\n            }else{\n                var temp_target=target;\n            }\n            temp_path.forEach(each=>{\n                temp_visited[(each[0]+1)+','+each[1]]=true;\n            });\n            while(temp[0]!=temp_target[0] || temp[1]!=temp_target[1]){\n                temp_path.push(temp);\n                var temp_neighbours=get_neighbours(temp[0],temp[1],temp_visited);\n                if(temp_neighbours.length===0){\n                    keep_original=true;\n                    break\n                };\n                var temp_next_index=getRndInteger(0,temp_neighbours.length);\n                var temp_next=temp_neighbours[temp_next_index];\n                temp=temp_next;\n            };\n            temp_path.push(temp);\n            if(target_reacher){\n                temp_path=temp_path.concat(child.path.slice(random_index,child.path.length))\n            };\n            if(keep_original){\n                temp_path=child.path;\n            };\n            var temp_child=new path(start, target)\n            temp_child.path=temp_path;\n            temp_child.fitness=get_fitness(temp_path,target)\n            return temp_child\n        };\n        return child;\n    };\n    var start=[x,y]\n    var population=document.getElementById(\"genetic_algo_population\").value;\n    var mutation_rate=document.getElementById(\"genetic_algo_mutation_rate\").value;\n    if(population==\"\" || mutation_rate==\"\"){alert('Enter population and mutation rate');return}\n    var current_generation=[];\n    for(var i=0;i<population;i++){\n        current_generation.push(new path(start,target));\n    };\n    var genetic_algorithm_interval=setInterval(() => {\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\n            clearInterval(genetic_algorithm_interval);\n            refresh();\n            return;\n        };\n        var total_fitness=0;\n        var max_fitness=0;\n        var max_fitness_index;\n        for(var i=0;i<current_generation.length;i++){\n            if(current_generation[i].fitness>max_fitness){\n                max_fitness=current_generation[i].fitness;\n                max_fitness_index=i;\n            };\n            total_fitness+=current_generation[i].fitness;\n        };\n        var max_fitness_path=current_generation[max_fitness_index].path;\n        current_generation.forEach(each=>{\n            each.prob=each.fitness/total_fitness;\n        });\n        if(max_fitness==Infinity){\n            genetic_algorithm(no_rows,no_columns);\n            return;\n        };\n        display(max_fitness_path);\n        var temp_generation=[]\n        for(var i=0;i<population;i++){\n            var parent1=get_parent_according_to_prob(current_generation);\n            var parent2=get_parent_according_to_prob(current_generation);\n            var temp=crossover2(parent1,parent2,start,target);\n            var temp=mutate(temp,mutation_rate,start,target);\n            temp_generation.push(temp);\n        };\n        current_generation=temp_generation;\n    },10)\n};",{"ruleId":"153","severity":1,"message":"154","line":14,"column":11,"nodeType":"155","messageId":"156","endLine":14,"endColumn":63},{"ruleId":"153","severity":1,"message":"157","line":16,"column":11,"nodeType":"155","messageId":"156","endLine":16,"endColumn":27},{"ruleId":"153","severity":1,"message":"158","line":19,"column":45,"nodeType":"155","messageId":"156","endLine":19,"endColumn":75},{"ruleId":"153","severity":1,"message":"159","line":57,"column":51,"nodeType":"155","messageId":"156","endLine":57,"endColumn":81},{"ruleId":"153","severity":1,"message":"160","line":58,"column":46,"nodeType":"155","messageId":"156","endLine":58,"endColumn":77},{"ruleId":"153","severity":1,"message":"161","line":59,"column":46,"nodeType":"155","messageId":"156","endLine":59,"endColumn":76},{"ruleId":"153","severity":1,"message":"162","line":60,"column":46,"nodeType":"155","messageId":"156","endLine":60,"endColumn":75},{"ruleId":"153","severity":1,"message":"163","line":61,"column":46,"nodeType":"155","messageId":"156","endLine":61,"endColumn":78},{"ruleId":"153","severity":1,"message":"164","line":63,"column":46,"nodeType":"155","messageId":"156","endLine":63,"endColumn":80},{"ruleId":"153","severity":1,"message":"165","line":64,"column":46,"nodeType":"155","messageId":"156","endLine":64,"endColumn":74},{"ruleId":"153","severity":1,"message":"166","line":65,"column":46,"nodeType":"155","messageId":"156","endLine":65,"endColumn":79},{"ruleId":"167","severity":1,"message":"168","line":31,"column":81,"nodeType":"169","messageId":"170","endLine":31,"endColumn":83},{"ruleId":"167","severity":1,"message":"168","line":39,"column":82,"nodeType":"169","messageId":"170","endLine":39,"endColumn":84},{"ruleId":"171","severity":1,"message":"172","line":46,"column":13,"nodeType":"173","messageId":"174","endLine":46,"endColumn":16},{"ruleId":"171","severity":1,"message":"175","line":47,"column":13,"nodeType":"173","messageId":"174","endLine":47,"endColumn":16},{"ruleId":"167","severity":1,"message":"168","line":147,"column":49,"nodeType":"169","messageId":"170","endLine":147,"endColumn":51},{"ruleId":"167","severity":1,"message":"168","line":165,"column":16,"nodeType":"169","messageId":"170","endLine":165,"endColumn":18},{"ruleId":"167","severity":1,"message":"168","line":166,"column":16,"nodeType":"169","messageId":"170","endLine":166,"endColumn":18},{"ruleId":"167","severity":1,"message":"168","line":167,"column":16,"nodeType":"169","messageId":"170","endLine":167,"endColumn":18},{"ruleId":"167","severity":1,"message":"168","line":168,"column":16,"nodeType":"169","messageId":"170","endLine":168,"endColumn":18},{"ruleId":"167","severity":1,"message":"168","line":175,"column":30,"nodeType":"169","messageId":"170","endLine":175,"endColumn":32},{"ruleId":"176","severity":1,"message":"177","line":14,"column":13,"nodeType":"155","endLine":14,"endColumn":37},{"ruleId":"176","severity":1,"message":"177","line":15,"column":13,"nodeType":"155","endLine":15,"endColumn":36},{"ruleId":"176","severity":1,"message":"177","line":12,"column":13,"nodeType":"155","endLine":12,"endColumn":45},{"ruleId":"176","severity":1,"message":"177","line":15,"column":13,"nodeType":"155","endLine":15,"endColumn":45},{"ruleId":"176","severity":1,"message":"177","line":16,"column":13,"nodeType":"155","endLine":16,"endColumn":42},{"ruleId":"176","severity":1,"message":"177","line":14,"column":13,"nodeType":"155","endLine":14,"endColumn":36},{"ruleId":"176","severity":1,"message":"177","line":15,"column":13,"nodeType":"155","endLine":15,"endColumn":38},{"ruleId":"176","severity":1,"message":"177","line":18,"column":13,"nodeType":"155","endLine":18,"endColumn":38},{"ruleId":"176","severity":1,"message":"177","line":19,"column":13,"nodeType":"155","endLine":19,"endColumn":32},{"ruleId":"176","severity":1,"message":"177","line":20,"column":13,"nodeType":"155","endLine":20,"endColumn":32},{"ruleId":"176","severity":1,"message":"177","line":21,"column":13,"nodeType":"155","endLine":21,"endColumn":32},{"ruleId":"176","severity":1,"message":"177","line":12,"column":13,"nodeType":"155","endLine":12,"endColumn":41},{"ruleId":"176","severity":1,"message":"177","line":17,"column":13,"nodeType":"155","endLine":17,"endColumn":39},{"ruleId":"176","severity":1,"message":"177","line":18,"column":13,"nodeType":"155","endLine":18,"endColumn":36},{"ruleId":"176","severity":1,"message":"177","line":19,"column":13,"nodeType":"155","endLine":19,"endColumn":36},{"ruleId":"176","severity":1,"message":"177","line":14,"column":13,"nodeType":"155","endLine":14,"endColumn":38},{"ruleId":"176","severity":1,"message":"177","line":15,"column":13,"nodeType":"155","endLine":15,"endColumn":37},{"ruleId":"176","severity":1,"message":"177","line":15,"column":13,"nodeType":"155","endLine":15,"endColumn":37},{"ruleId":"176","severity":1,"message":"177","line":16,"column":13,"nodeType":"155","endLine":16,"endColumn":36},{"ruleId":"167","severity":1,"message":"168","line":84,"column":89,"nodeType":"169","messageId":"170","endLine":84,"endColumn":91},{"ruleId":"167","severity":1,"message":"168","line":100,"column":52,"nodeType":"169","messageId":"170","endLine":100,"endColumn":54},{"ruleId":"167","severity":1,"message":"168","line":61,"column":89,"nodeType":"169","messageId":"170","endLine":61,"endColumn":91},{"ruleId":"167","severity":1,"message":"168","line":78,"column":89,"nodeType":"169","messageId":"170","endLine":78,"endColumn":91},{"ruleId":"167","severity":1,"message":"178","line":84,"column":26,"nodeType":"169","messageId":"170","endLine":84,"endColumn":28},{"ruleId":"167","severity":1,"message":"178","line":84,"column":48,"nodeType":"169","messageId":"170","endLine":84,"endColumn":50},{"ruleId":"171","severity":1,"message":"179","line":217,"column":17,"nodeType":"173","messageId":"174","endLine":217,"endColumn":26},{"ruleId":"171","severity":1,"message":"180","line":231,"column":21,"nodeType":"173","messageId":"174","endLine":231,"endColumn":32},{"ruleId":"167","severity":1,"message":"178","line":236,"column":26,"nodeType":"169","messageId":"170","endLine":236,"endColumn":28},{"ruleId":"167","severity":1,"message":"178","line":236,"column":53,"nodeType":"169","messageId":"170","endLine":236,"endColumn":55},{"ruleId":"171","severity":1,"message":"181","line":254,"column":17,"nodeType":"173","messageId":"174","endLine":254,"endColumn":27},{"ruleId":"167","severity":1,"message":"168","line":264,"column":18,"nodeType":"169","messageId":"170","endLine":264,"endColumn":20},{"ruleId":"167","severity":1,"message":"168","line":264,"column":39,"nodeType":"169","messageId":"170","endLine":264,"endColumn":41},{"ruleId":"171","severity":1,"message":"182","line":266,"column":13,"nodeType":"173","messageId":"174","endLine":266,"endColumn":14},{"ruleId":"167","severity":1,"message":"168","line":270,"column":89,"nodeType":"169","messageId":"170","endLine":270,"endColumn":91},{"ruleId":"167","severity":1,"message":"168","line":289,"column":23,"nodeType":"169","messageId":"170","endLine":289,"endColumn":25},{"ruleId":"171","severity":1,"message":"182","line":295,"column":17,"nodeType":"173","messageId":"174","endLine":295,"endColumn":18},{"ruleId":"171","severity":1,"message":"183","line":299,"column":17,"nodeType":"173","messageId":"174","endLine":299,"endColumn":21},"react/jsx-pascal-case","Imported JSX component Maze_control must be in PascalCase or SCREAMING_SNAKE_CASE","JSXOpeningElement","usePascalOrSnakeCase","Imported JSX component User_Mannual must be in PascalCase or SCREAMING_SNAKE_CASE","Imported JSX component More_options must be in PascalCase or SCREAMING_SNAKE_CASE","Imported JSX component Select_start must be in PascalCase or SCREAMING_SNAKE_CASE","Imported JSX component Select_target must be in PascalCase or SCREAMING_SNAKE_CASE","Imported JSX component Maze_builder must be in PascalCase or SCREAMING_SNAKE_CASE","Imported JSX component Maze_eraser must be in PascalCase or SCREAMING_SNAKE_CASE","Imported JSX component Maze_generator must be in PascalCase or SCREAMING_SNAKE_CASE","Imported JSX component Select_algorithm must be in PascalCase or SCREAMING_SNAKE_CASE","Imported JSX component GA_options must be in PascalCase or SCREAMING_SNAKE_CASE","Imported JSX component Start_stop_algo must be in PascalCase or SCREAMING_SNAKE_CASE","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-redeclare","'min' is already defined.","Identifier","redeclared","'max' is already defined.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","Expected '!==' and instead saw '!='.","'temp_path' is already defined.","'temp_target' is already defined.","'temp_child' is already defined.","'i' is already defined.","'temp' is already defined."]