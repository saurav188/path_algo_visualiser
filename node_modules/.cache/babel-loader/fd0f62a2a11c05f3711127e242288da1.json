{"ast":null,"code":"// A* path finding algorithm \n\nfunction A_star(no_rows, no_columns) {\n  const grids = Array.from(document.getElementsByClassName('grid'));\n  var x, y;\n  var found_start = false;\n  var target = [];\n  var found_target = false;\n  var i = 0;\n  // find target and start cooridinates\n  grids.forEach(grid => {\n    if (grid.classList.contains('start')) {\n      y = Math.floor(i / no_columns) + 1;\n      x = i % no_columns + 1;\n      found_start = true;\n    } else if (grid.classList.contains('target')) {\n      target.push(i % no_columns + 1);\n      target.push(Math.floor(i / no_columns) + 1);\n      found_target = true;\n    }\n    ;\n    i++;\n  });\n  if (!found_start || !found_target) {\n    alert('choose target and start grid');\n    return;\n  }\n  ;\n  //get all available neighbours of the given grid(x,y)\n  function get_neighbours(x, y, visited) {\n    var neighbours = [];\n    var index = (y - 1) * no_columns + (x - 1);\n    //top neighbour\n    if (y - 1 > 0 && !grids[index - no_columns].classList.contains('obstacle') && visited[x + ',' + (y - 1)] === undefined) {\n      neighbours.push([x, y - 1]);\n    }\n    ;\n    //right neighbour\n    if (x + 1 <= no_columns && !grids[index + 1].classList.contains('obstacle') && visited[x + 1 + ',' + y] === undefined) {\n      neighbours.push([x + 1, y]);\n    }\n    ;\n    //bottom neighbour\n    if (y + 1 <= no_rows && !grids[index + no_columns].classList.contains('obstacle') && visited[x + ',' + (y + 1)] === undefined) {\n      neighbours.push([x, y + 1]);\n    }\n    ;\n    //left neighbour\n    if (x - 1 > 0 && !grids[index - 1].classList.contains('obstacle') && visited[x - 1 + ',' + y] === undefined) {\n      neighbours.push([x - 1, y]);\n    }\n    ;\n    return neighbours;\n  }\n  ;\n  // heuristic function for current\n  function get_heuristic(current, target) {\n    return dist[current[0] + ',' + current[1]] + Math.abs(target[0] - current[0]) + Math.abs(target[1] - current[1]);\n  }\n  ;\n  found_target = false;\n  var start = [x, y];\n  var open = [[x, y]];\n  var visited = {};\n  var j = 1;\n  var k = 1;\n  var active_grids = [];\n  //puts all the active grid to the array gids\n  grids.forEach(grid => {\n    if (!grid.classList.contains('obstacle')) {\n      active_grids.push([j, k]);\n    }\n    ;\n    if (j === no_columns) {\n      k++;\n      j = 1;\n    } else {\n      j++;\n    }\n    ;\n  });\n  let dist = {};\n  let parent = {};\n  //dist from start of all the grids is infinity \n  active_grids.forEach(each => {\n    dist[each[0] + ',' + each[1]] = 999999;\n  });\n  //dist of start from start is 0\n  dist[x + ',' + y] = 0;\n  var neighbours, winner, current, temp;\n  i = 1;\n  var intervalId = null;\n  intervalId = setInterval(() => {\n    if (document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML == \"false\") {\n      //stop the algorithm from running\n      clearInterval(intervalId);\n      return;\n    }\n    ;\n    if (open.length <= 0 || found_target) {\n      clearInterval(intervalId);\n    }\n    if (!found_target) {\n      winner = 0;\n      // chooses a winner with the least heuristic\n      for (var i = 0; i < open.length; i++) {\n        if (get_heuristic(open[i], target) < get_heuristic(open[winner], target)) {\n          winner = i;\n        }\n        ;\n      }\n      ;\n      current = open[winner];\n      //if cuurent is the target stop \n      if (current[0] === target[0] && current[1] == target[1]) {\n        found_target = true;\n        x = current[0];\n        y = current[1];\n        return;\n      }\n      ;\n      //remove current from open array\n      open.splice(winner, 1);\n      visited[current[0] + ',' + current[1]] = true;\n      neighbours = get_neighbours(current[0], current[1], visited);\n      neighbours.forEach(neighbour => {\n        //finds if neighbour is reached yet \n        if (dist[current[0] + ',' + current[1]] + 1 < dist[neighbour[0] + ',' + neighbour[1]]) {\n          //this distance < Infinity if not visited\n          //add nearest parent to neibour and new distance \n          dist[neighbour[0] + ',' + neighbour[1]] = dist[current[0] + ',' + current[1]] + 1;\n          parent[neighbour[0] + ',' + neighbour[1]] = [current[0], current[1]];\n          if (!(neighbour in open)) {\n            //add neighbout to open if its not in it yet\n            open.push(neighbour);\n          }\n          ;\n          //showt the grid as seen if the grid is not the start or the target\n          if (!grids[(neighbour[1] - 1) * no_columns + (neighbour[0] - 1)].classList.contains('start') && !grids[(neighbour[1] - 1) * no_columns + (neighbour[0] - 1)].classList.contains('target')) {\n            grids[(neighbour[1] - 1) * no_columns + (neighbour[0] - 1)].classList.add('seen');\n          }\n          ;\n        }\n        ;\n      });\n    } else {\n      //display the final path found\n      while (!(x === start[0] && y === start[1])) {\n        if (!grids[(y - 1) * no_columns + (x - 1)].classList.contains('start') && !grids[(y - 1) * no_columns + (x - 1)].classList.contains('target')) {\n          grids[(y - 1) * no_columns + (x - 1)].classList.add('path');\n        }\n        ;\n        temp = parent[x + ',' + y];\n        x = temp[0];\n        y = temp[1];\n      }\n      ;\n    }\n  }, 25);\n}\n_c = A_star;\n;\nexport default A_star;\nvar _c;\n$RefreshReg$(_c, \"A_star\");","map":{"version":3,"names":["A_star","no_rows","no_columns","grids","Array","from","document","getElementsByClassName","x","y","found_start","target","found_target","i","forEach","grid","classList","contains","Math","floor","push","alert","get_neighbours","visited","neighbours","index","undefined","get_heuristic","current","dist","abs","start","open","j","k","active_grids","parent","each","winner","temp","intervalId","setInterval","getElementById","innerHTML","clearInterval","length","splice","neighbour","add","_c","$RefreshReg$"],"sources":["/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/A_star.js"],"sourcesContent":["// A* path finding algorithm \n\nfunction A_star(no_rows,no_columns){\n    const grids=Array.from(document.getElementsByClassName('grid'));\n    var x,y;\n    var found_start=false;\n    var target=[]\n    var found_target=false;\n    var i=0;\n    // find target and start cooridinates\n    grids.forEach(grid=>{\n        if(grid.classList.contains('start')){\n            y=Math.floor(i/no_columns)+1;\n            x=(i%no_columns)+1;\n            found_start=true;\n        }else if(grid.classList.contains('target')){\n            target.push((i%no_columns)+1);\n            target.push(Math.floor(i/no_columns)+1);\n            found_target=true;\n        };\n        i++;\n    });\n    if(!found_start || !found_target){\n        alert('choose target and start grid');\n        return\n    };\n    //get all available neighbours of the given grid(x,y)\n    function get_neighbours(x,y,visited){\n        var neighbours=[];\n        var index=((y-1)*no_columns)+(x-1)\n        //top neighbour\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle') && visited[x+','+(y-1)]===undefined){\n            neighbours.push([x,(y-1)])\n        };\n        //right neighbour\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle') && visited[(x+1)+','+y]===undefined){\n            neighbours.push([(x+1),y])\n        };\n        //bottom neighbour\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle') && visited[x+','+(y+1)]===undefined){\n            neighbours.push([x,(y+1)])\n        };\n        //left neighbour\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle') && visited[(x-1)+','+y]===undefined){\n            neighbours.push([(x-1),y])\n        };\n        return neighbours;\n    };\n    // heuristic function for current\n    function get_heuristic(current,target){\n        return  dist[current[0]+','+current[1]]+(Math.abs(target[0]-current[0]))+(Math.abs(target[1]-current[1]));\n    };\n    found_target=false;\n    var start=[x,y]\n    var open=[[x,y]];\n    var visited={};\n    var j=1;\n    var k=1;\n    var active_grids=[];\n    //puts all the active grid to the array gids\n    grids.forEach(grid=>{\n        if(!grid.classList.contains('obstacle')){\n            active_grids.push([j,k]);\n        };\n        if(j===no_columns){\n            k++;\n            j=1;\n        }else{\n            j++;\n        };\n    });\n    let dist={};\n    let parent={}\n    //dist from start of all the grids is infinity \n    active_grids.forEach(each=>{\n        dist[each[0]+','+each[1]]=999999;\n    });\n    //dist of start from start is 0\n    dist[x+','+y]=0;\n    var neighbours,winner,current,temp;\n    i=1;\n    var intervalId=null;\n    intervalId=setInterval(()=>{\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\n            //stop the algorithm from running\n            clearInterval(intervalId);\n            return;\n        };\n        if(open.length<=0||found_target){clearInterval(intervalId);}\n        if(!found_target){\n            winner=0;\n            // chooses a winner with the least heuristic\n            for(var i=0;i<open.length;i++){\n                if(get_heuristic(open[i],target)<get_heuristic(open[winner],target)){\n                    winner=i;\n                };\n            };\n            current=open[winner];\n            //if cuurent is the target stop \n            if(current[0]===target[0] && current[1]==target[1]){\n                found_target=true;\n                x=current[0];\n                y=current[1];\n                return\n            };\n            //remove current from open array\n            open.splice(winner,1);\n            visited[current[0]+','+current[1]]=true;\n            neighbours=get_neighbours(current[0],current[1],visited);\n            neighbours.forEach(neighbour=>{\n                //finds if neighbour is reached yet \n                if(dist[current[0]+','+current[1]]+1<dist[neighbour[0]+','+neighbour[1]]){//this distance < Infinity if not visited\n                    //add nearest parent to neibour and new distance \n                    dist[neighbour[0]+','+neighbour[1]]=dist[current[0]+','+current[1]]+1;\n                    parent[neighbour[0]+','+neighbour[1]]=[current[0],current[1]];\n                    if(!(neighbour in open)){\n                        //add neighbout to open if its not in it yet\n                        open.push(neighbour)\n                    };\n                    //showt the grid as seen if the grid is not the start or the target\n                    if(!grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('start')\n                        && !grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('target')){\n                            grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.add('seen');\n                    };\n                };\n            });\n        }else{\n            //display the final path found\n            while(!(x===start[0] && y===start[1])){\n            if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start') && \n                !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\n                    grids[((y-1)*no_columns)+(x-1)].classList.add('path');\n            };\n            temp=parent[x+','+y];\n            x=temp[0];\n            y=temp[1];\n        };\n        }\n    },25);\n};\n\nexport default A_star;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}