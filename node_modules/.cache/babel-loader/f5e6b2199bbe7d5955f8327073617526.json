{"ast":null,"code":"export default function genetic_algorithm(no_rows, no_columns) {\n  const grids = Array.from(document.getElementsByClassName('grid'));\n  var x, y;\n  var found_start = false;\n  var target = [];\n  var found_target = false;\n  var i = 0;\n  //finds start and target\n  grids.forEach(grid => {\n    if (grid.classList.contains('start')) {\n      y = Math.floor(i / no_columns) + 1;\n      x = i % no_columns + 1;\n      found_start = true;\n    } else if (grid.classList.contains('target')) {\n      target.push(i % no_columns + 1);\n      target.push(Math.floor(i / no_columns) + 1);\n      found_target = true;\n    }\n    ;\n    i++;\n  });\n  //checks if start and target is found\n  if (!found_start || !found_target) {\n    alert('choose target and start grid');\n    return;\n  }\n  ;\n  //gets all the valid, non-visited neighbours\n  function get_neighbours(x, y, visited) {\n    var neighbours = [];\n    var index = (y - 1) * no_columns + (x - 1);\n    visited[x + ',' + y] = true;\n    //top neighbour\n    if (y - 1 > 0 && !grids[index - no_columns].classList.contains('obstacle') && visited[x + ',' + (y - 1)] === undefined) {\n      neighbours.push([x, y - 1]);\n      visited[x + ',' + (y - 1)] = true;\n    }\n    ;\n    //right neighbour\n    if (x + 1 <= no_columns && !grids[index + 1].classList.contains('obstacle') && visited[x + 1 + ',' + y] === undefined) {\n      neighbours.push([x + 1, y]);\n      visited[x + 1 + ',' + y] = true;\n    }\n    ;\n    //bottom neighbour\n    if (y + 1 <= no_rows && !grids[index + no_columns].classList.contains('obstacle') && visited[x + ',' + (y + 1)] === undefined) {\n      neighbours.push([x, y + 1]);\n      visited[x + ',' + (y + 1)] = true;\n    }\n    ;\n    //left neighbour\n    if (x - 1 > 0 && !grids[index - 1].classList.contains('obstacle') && visited[x - 1 + ',' + y] === undefined) {\n      neighbours.push([x - 1, y]);\n      visited[x - 1 + ',' + y] = true;\n    }\n    ;\n    return neighbours;\n  }\n  ;\n  //random no x => min<=x<max\n  function getRndInteger(min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n  }\n  ;\n  //removes the current path\n  function refresh() {\n    const grids = Array.from(document.getElementsByClassName('grid'));\n    grids.forEach(each => {\n      if (each.classList.contains('path')) {\n        each.classList.remove('path');\n      }\n      ;\n    });\n  }\n  ;\n  //dispalys the given path\n  function display(max_fitness_path) {\n    refresh();\n    max_fitness_path.forEach(each => {\n      if (!grids[(each[1] - 1) * no_columns + (each[0] - 1)].classList.contains('start') && !grids[(each[1] - 1) * no_columns + (each[0] - 1)].classList.contains('target')) {\n        grids[(each[1] - 1) * no_columns + (each[0] - 1)].classList.add('path');\n      }\n      ;\n    });\n  }\n  //path class\n  class path {\n    //initialpath setup\n    constructor(start, target) {\n      var temp_path = [];\n      var temp = start;\n      var temp_visited = {};\n      //builds a path\n      while (temp[0] != target[0] || temp[1] != target[1]) {\n        var temp_neighbours = get_neighbours(temp[0], temp[1], temp_visited);\n        if (temp_neighbours.length === 0) {\n          break;\n        }\n        ;\n        var temp_next_index = getRndInteger(0, temp_neighbours.length);\n        var temp_next = temp_neighbours[temp_next_index];\n        temp_path.push(temp_next);\n        temp = temp_next;\n      }\n      ;\n      //adds fitness\n      var temp_fitness = 25000;\n      if (temp[0] !== target[0] || temp[1] !== target[1]) {\n        temp_fitness = 1000;\n      }\n      temp_fitness = temp_fitness / (temp_path.length ^ 2);\n      this.path = temp_path;\n      this.fitness = Math.abs(temp_fitness);\n    }\n  }\n  ;\n  //gets a random parent from the given generation according to probability\n  function get_parent_according_to_prob(current_generation) {\n    var i = Math.random();\n    var index = 0;\n    //if probability of path i is 0.5 then it has 50% chance of chooseing\n    //because if i<0.5 then it is choosen and chance of i<0.5 is 50%\n    while (i > 0) {\n      i -= current_generation[index].prob;\n      index++;\n    }\n    ;\n    return current_generation[index - 1];\n  }\n  ;\n  //gives fitness of the path with respect to the target\n  function get_fitness(path, target) {\n    var temp_fitness = 250000;\n    var temp = path[path.length - 1];\n    if (temp[0] !== target[0] || temp[1] !== target[1]) {\n      temp_fitness = 1000;\n    }\n    temp_fitness = temp_fitness / (path.length ^ 2);\n    return Math.abs(temp_fitness);\n  }\n  ;\n  //does crossover between to path gives a child path of these to path\n  function crossover2(parent1, parent2, start, target) {\n    var parent1_visited = {};\n    var parent2_visited = {};\n    var i = 0;\n    var j = 0;\n    var resulting_path = [];\n    var path1 = parent1.path;\n    var path2 = parent2.path;\n    var both_reaches_target, parent1_reaches_target, parent2_reaches_target;\n    var crossover_complete = false;\n    //run the look until both paths grid can be read\n    while (i < path1.length && j < path2.length) {\n      //save the index of the grids visited\n      parent1_visited[path1[i][0] + ',' + path1[i][1]] = i;\n      parent2_visited[path2[j][0] + ',' + path2[j][1]] = j;\n      //if the current path2 grid is already visited by path1\n      //the path till that grid is small for path1\n      if (parent1_visited[path2[j][0] + ',' + path2[j][1]] !== undefined) {\n        resulting_path = resulting_path.concat(path1.slice(0, parent1_visited[path2[j][0] + ',' + path2[j][1]] + 1));\n        parent1_reaches_target = path1[path1.length - 1][0] === target[0] && path1[path1.length - 1][1] === target[1];\n        parent2_reaches_target = path2[path2.length - 1][0] === target[0] && path2[path2.length - 1][1] === target[1];\n        both_reaches_target = parent1_reaches_target && parent2_reaches_target;\n        //if both reaches target \n        if (both_reaches_target) {\n          if (path1.length - parent1_visited[path2[j][0] + ',' + path2[j][1]] < path2.length - j) {\n            resulting_path = resulting_path.concat(path1.slice(parent1_visited[path2[j][0] + ',' + path2[j][1]] + 1, path1.length));\n          } else {\n            resulting_path = resulting_path.concat(path2.slice(j + 1, path2.length));\n          }\n        } else if (parent1_reaches_target) {\n          resulting_path = resulting_path.concat(path1.slice(parent1_visited[path2[j][0] + ',' + path2[j][1]] + 1, path1.length));\n        } else if (parent2_reaches_target) {\n          resulting_path = resulting_path.concat(path2.slice(j + 1, path2.length));\n        } else {\n          resulting_path = resulting_path.concat(path2.slice(j + 1, path2.length));\n        }\n        ;\n        crossover_complete = true;\n        break;\n      } else if (parent2_visited[path1[i][0] + ',' + path1[i][1]] !== undefined) {\n        resulting_path = resulting_path.concat(path2.slice(0, parent2_visited[path1[i][0] + ',' + path1[i][1]] + 1));\n        parent1_reaches_target = path1[path1.length - 1][0] === target[0] && path1[path1.length - 1][1] === target[1];\n        parent2_reaches_target = path2[path2.length - 1][0] === target[0] && path2[path2.length - 1][1] === target[1];\n        both_reaches_target = parent1_reaches_target && parent2_reaches_target;\n        if (both_reaches_target) {\n          if (path2.length - parent2_visited[path1[i][0] + ',' + path1[i][1]] < path1.length - i) {\n            resulting_path = resulting_path.concat(path2.slice(parent2_visited[path1[i][0] + ',' + path1[i][1]] + 1, path2.length));\n          } else {\n            resulting_path = resulting_path.concat(path1.slice(i + 1, path1.length));\n          }\n        } else if (parent2_reaches_target) {\n          resulting_path = resulting_path.concat(path2.slice(parent2_visited[path1[i][0] + ',' + path1[i][1]] + 1, path2.length));\n        } else if (parent1_reaches_target) {\n          resulting_path = resulting_path.concat(path1.slice(i + 1, path1.length));\n        } else {\n          resulting_path = resulting_path.concat(path1.slice(i + 1, path1.length));\n        }\n        ;\n        crossover_complete = true;\n        break;\n      } else if (path1[i][0] === target[0] && path1[i][1] === target[1]) {\n        resulting_path = resulting_path.concat(path1.slice(0, i + 1));\n        crossover_complete = true;\n        break;\n      } else if (path2[j][0] === target[0] && path2[j][1] === target[1]) {\n        resulting_path = resulting_path.concat(path2.slice(0, j + 1));\n        crossover_complete = true;\n        break;\n      } else {\n        i += 1;\n        j += 1;\n      }\n      ;\n    }\n    ;\n    if (!crossover_complete) {\n      resulting_path = path1;\n    }\n    var temp_child = new path(start, target);\n    temp_child.path = resulting_path;\n    temp_child.fitness = get_fitness(resulting_path, target);\n    return temp_child;\n  }\n  ;\n  //mutates the given path\n  function mutate(child, mutation_rate, start, target) {\n    var random_no = Math.random();\n    if (random_no * 100 - mutation_rate < 0) {\n      var temp_child = new path(start, target);\n      var temp_path = child.path;\n      var random_index = getRndInteger(0, temp_path.length);\n      var temp_path = temp_path.slice(0, random_index);\n      var temp = child.path[random_index];\n      var temp_visited = {};\n      var keep_original = false;\n      var target_reacher = child.path[child.path.length - 1][0] === target[0] && child.path[child.path.length - 1][1] === target[1];\n      if (target_reacher) {\n        var random_index_two_steps_from_target = random_index + 2 < child.path.length;\n        if (random_index_two_steps_from_target) {\n          random_index = getRndInteger(random_index + 1, child.path.length);\n        } else {\n          random_index = child.path.length - 1;\n        }\n        var temp_target = child.path[random_index];\n      } else {\n        var temp_target = target;\n      }\n      temp_path.forEach(each => {\n        temp_visited[each[0] + 1 + ',' + each[1]] = true;\n      });\n      while (temp[0] != temp_target[0] || temp[1] != temp_target[1]) {\n        temp_path.push(temp);\n        var temp_neighbours = get_neighbours(temp[0], temp[1], temp_visited);\n        if (temp_neighbours.length === 0) {\n          keep_original = true;\n          break;\n        }\n        ;\n        var temp_next_index = getRndInteger(0, temp_neighbours.length);\n        var temp_next = temp_neighbours[temp_next_index];\n        temp = temp_next;\n      }\n      ;\n      temp_path.push(temp);\n      if (target_reacher) {\n        temp_path = temp_path.concat(child.path.slice(random_index, child.path.length));\n      }\n      ;\n      if (keep_original) {\n        temp_path = child.path;\n      }\n      ;\n      var temp_child = new path(start, target);\n      temp_child.path = temp_path;\n      temp_child.fitness = get_fitness(temp_path, target);\n      return temp_child;\n    }\n    ;\n    return child;\n  }\n  ;\n  var start = [x, y];\n  var population = document.getElementById(\"genetic_algo_population\").value;\n  var mutation_rate = document.getElementById(\"genetic_algo_mutation_rate\").value;\n  if (population == \"\" || mutation_rate == \"\") {\n    alert('Enter population and mutation rate');\n    return;\n  }\n  var current_generation = [];\n  for (var i = 0; i < population; i++) {\n    current_generation.push(new path(start, target));\n  }\n  ;\n  var genetic_algorithm_interval = setInterval(() => {\n    if (document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML == \"false\") {\n      clearInterval(genetic_algorithm_interval);\n      refresh();\n      return;\n    }\n    ;\n    var total_fitness = 0;\n    var max_fitness = 0;\n    var max_fitness_index;\n    for (var i = 0; i < current_generation.length; i++) {\n      if (current_generation[i].fitness > max_fitness) {\n        max_fitness = current_generation[i].fitness;\n        max_fitness_index = i;\n      }\n      ;\n      total_fitness += current_generation[i].fitness;\n    }\n    ;\n    var max_fitness_path = current_generation[max_fitness_index].path;\n    current_generation.forEach(each => {\n      each.prob = each.fitness / total_fitness;\n    });\n    if (max_fitness == Infinity) {\n      genetic_algorithm(no_rows, no_columns);\n      return;\n    }\n    ;\n    display(max_fitness_path);\n    var temp_generation = [];\n    for (var i = 0; i < population; i++) {\n      var parent1 = get_parent_according_to_prob(current_generation);\n      var parent2 = get_parent_according_to_prob(current_generation);\n      var temp = crossover2(parent1, parent2, start, target);\n      var temp = mutate(temp, mutation_rate, start, target);\n      temp_generation.push(temp);\n    }\n    ;\n    current_generation = temp_generation;\n  }, 10);\n}\n;","map":{"version":3,"names":["genetic_algorithm","no_rows","no_columns","grids","Array","from","document","getElementsByClassName","x","y","found_start","target","found_target","i","forEach","grid","classList","contains","Math","floor","push","alert","get_neighbours","visited","neighbours","index","undefined","getRndInteger","min","max","random","refresh","each","remove","display","max_fitness_path","add","path","constructor","start","temp_path","temp","temp_visited","temp_neighbours","length","temp_next_index","temp_next","temp_fitness","fitness","abs","get_parent_according_to_prob","current_generation","prob","get_fitness","crossover2","parent1","parent2","parent1_visited","parent2_visited","j","resulting_path","path1","path2","both_reaches_target","parent1_reaches_target","parent2_reaches_target","crossover_complete","concat","slice","temp_child","mutate","child","mutation_rate","random_no","random_index","keep_original","target_reacher","random_index_two_steps_from_target","temp_target","population","getElementById","value","genetic_algorithm_interval","setInterval","innerHTML","clearInterval","total_fitness","max_fitness","max_fitness_index","Infinity","temp_generation"],"sources":["/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/Genetic_algorithm.js"],"sourcesContent":["export default function genetic_algorithm(no_rows,no_columns){\n    const grids=Array.from(document.getElementsByClassName('grid'));\n    var x,y;\n    var found_start=false;\n    var target=[]\n    var found_target=false;\n    var i=0;\n    //finds start and target\n    grids.forEach(grid=>{\n        if(grid.classList.contains('start')){\n            y=Math.floor(i/no_columns)+1;\n            x=(i%no_columns)+1;\n            found_start=true;\n        }else if(grid.classList.contains('target')){\n            target.push((i%no_columns)+1);\n            target.push(Math.floor(i/no_columns)+1);\n            found_target=true;\n        };\n        i++;\n    });\n    //checks if start and target is found\n    if(!found_start || !found_target){\n        alert('choose target and start grid');\n        return\n    };\n    //gets all the valid, non-visited neighbours\n    function get_neighbours(x,y,visited){\n        var neighbours=[];\n        var index=((y-1)*no_columns)+(x-1);\n        visited[x+','+y]=true;\n        //top neighbour\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle') && visited[x+','+(y-1)]===undefined){\n            neighbours.push([x,(y-1)]);\n            visited[x+','+(y-1)]=true;\n        };\n        //right neighbour\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle') && visited[(x+1)+','+y]===undefined){\n            neighbours.push([(x+1),y]);\n            visited[(x+1)+','+y]=true;\n        };\n        //bottom neighbour\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle') && visited[x+','+(y+1)]===undefined){\n            neighbours.push([x,(y+1)]);\n            visited[x+','+(y+1)]=true;\n        };\n        //left neighbour\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle') && visited[(x-1)+','+y]===undefined){\n            neighbours.push([(x-1),y]);\n            visited[(x-1)+','+y]=true;\n        };\n        return neighbours;\n    };\n    //random no x => min<=x<max\n    function getRndInteger(min, max) {\n        return Math.floor(Math.random() * (max - min) ) + min;\n    };\n    //removes the current path\n    function refresh(){\n        const grids=Array.from(document.getElementsByClassName('grid'));\n        grids.forEach(each=>{\n            if(each.classList.contains('path')){\n                each.classList.remove('path');\n            };\n        });\n    };\n    //dispalys the given path\n    function display(max_fitness_path){\n        refresh();\n        max_fitness_path.forEach(each=>{\n            if(!grids[((each[1]-1)*no_columns)+(each[0]-1)].classList.contains('start') && \n                !grids[((each[1]-1)*no_columns)+(each[0]-1)].classList.contains('target')){\n                    grids[((each[1]-1)*no_columns)+(each[0]-1)].classList.add('path');\n            };\n        });\n    }\n    //path class\n    class path {\n        //initialpath setup\n        constructor(start,target){\n            var temp_path=[];\n            var temp=start;\n            var temp_visited={};\n            //builds a path\n            while(temp[0]!=target[0] || temp[1]!=target[1]){\n                var temp_neighbours=get_neighbours(temp[0],temp[1],temp_visited);\n                if(temp_neighbours.length===0){break};\n                var temp_next_index=getRndInteger(0,temp_neighbours.length);\n                var temp_next=temp_neighbours[temp_next_index];\n                temp_path.push(temp_next);\n                temp=temp_next;\n            };\n            //adds fitness\n            var temp_fitness=25000;\n            if(temp[0]!==target[0] || temp[1]!==target[1]){temp_fitness=1000}\n            temp_fitness=temp_fitness/(temp_path.length^2);\n            this.path=temp_path;\n            this.fitness=Math.abs(temp_fitness);\n        };\n    };\n    //gets a random parent from the given generation according to probability\n    function get_parent_according_to_prob(current_generation){\n        var i=Math.random()\n        var index=0\n        //if probability of path i is 0.5 then it has 50% chance of chooseing\n        //because if i<0.5 then it is choosen and chance of i<0.5 is 50%\n        while(i>0){\n            i-=current_generation[index].prob;\n            index++;\n        };\n        return current_generation[index-1]\n    };\n    //gives fitness of the path with respect to the target\n    function get_fitness(path,target){\n        var temp_fitness=250000;\n        var temp=path[path.length-1]\n        if(temp[0]!==target[0] || temp[1]!==target[1]){temp_fitness=1000}\n        temp_fitness=temp_fitness/(path.length^2);\n        return Math.abs(temp_fitness);\n    };\n    //does crossover between to path gives a child path of these to path\n    function crossover2(parent1,parent2,start,target){\n        var parent1_visited={};\n        var parent2_visited={};\n        var i=0;\n        var j=0;\n        var resulting_path=[];\n        var path1=parent1.path;\n        var path2=parent2.path;\n        var both_reaches_target,parent1_reaches_target,parent2_reaches_target;\n        var crossover_complete=false;\n        //run the look until both paths grid can be read\n        while(i<path1.length && j<path2.length){\n            //save the index of the grids visited\n            parent1_visited[path1[i][0]+','+path1[i][1]]=i;\n            parent2_visited[path2[j][0]+','+path2[j][1]]=j;\n            //if the current path2 grid is already visited by path1\n            //the path till that grid is small for path1\n            if(parent1_visited[path2[j][0]+','+path2[j][1]]!==undefined){\n                resulting_path=resulting_path.concat(path1.slice(0,parent1_visited[path2[j][0]+','+path2[j][1]]+1));\n                parent1_reaches_target=path1[path1.length-1][0]===target[0] && path1[path1.length-1][1]===target[1];\n                parent2_reaches_target=path2[path2.length-1][0]===target[0] && path2[path2.length-1][1]===target[1];\n                both_reaches_target=parent1_reaches_target && parent2_reaches_target;\n                //if both reaches target \n                if(both_reaches_target){\n                    if((path1.length-parent1_visited[path2[j][0]+','+path2[j][1]])<(path2.length-j)){\n                        resulting_path=resulting_path.concat(path1.slice(parent1_visited[path2[j][0]+','+path2[j][1]]+1,path1.length))\n                    }else{\n                        resulting_path=resulting_path.concat(path2.slice(j+1,path2.length))\n                    }\n                }\n                else if(parent1_reaches_target){\n                    resulting_path=resulting_path.concat(path1.slice(parent1_visited[path2[j][0]+','+path2[j][1]]+1,path1.length))\n                }\n                else if(parent2_reaches_target){\n                    resulting_path=resulting_path.concat(path2.slice(j+1,path2.length))\n                }\n                else{\n                    resulting_path=resulting_path.concat(path2.slice(j+1,path2.length))\n                };\n                crossover_complete=true;\n                break;\n            }\n            else if(parent2_visited[path1[i][0]+','+path1[i][1]]!==undefined){\n                resulting_path=resulting_path.concat(path2.slice(0,parent2_visited[path1[i][0]+','+path1[i][1]]+1));\n                parent1_reaches_target=path1[path1.length-1][0]===target[0] && path1[path1.length-1][1]===target[1];\n                parent2_reaches_target=path2[path2.length-1][0]===target[0] && path2[path2.length-1][1]===target[1];\n                both_reaches_target=parent1_reaches_target && parent2_reaches_target;\n                if(both_reaches_target){\n                    if((path2.length-parent2_visited[path1[i][0]+','+path1[i][1]])<(path1.length-i)){\n                        resulting_path=resulting_path.concat(path2.slice(parent2_visited[path1[i][0]+','+path1[i][1]]+1,path2.length))\n                    }else{\n                        resulting_path=resulting_path.concat(path1.slice(i+1,path1.length))\n                    }\n                }\n                else if(parent2_reaches_target){\n                    resulting_path=resulting_path.concat(path2.slice(parent2_visited[path1[i][0]+','+path1[i][1]]+1,path2.length))\n                }\n                else if(parent1_reaches_target){\n                    resulting_path=resulting_path.concat(path1.slice(i+1,path1.length))\n                }\n                else{\n                    resulting_path=resulting_path.concat(path1.slice(i+1,path1.length))\n                };\n                crossover_complete=true;\n                break;\n            }\n            else if(path1[i][0]===target[0] && path1[i][1]===target[1]){\n                resulting_path=resulting_path.concat(path1.slice(0,i+1));\n                crossover_complete=true;\n                break;\n            }\n            else if(path2[j][0]===target[0] && path2[j][1]===target[1]){\n                resulting_path=resulting_path.concat(path2.slice(0,j+1));\n                crossover_complete=true;\n                break;\n            }\n            else{\n                i+=1;\n                j+=1;\n            };\n        };\n        if(!crossover_complete){\n            resulting_path=path1;\n        }\n        var temp_child=new path(start,target)\n        temp_child.path=resulting_path;\n        temp_child.fitness=get_fitness(resulting_path,target)\n        return temp_child\n    };\n    //mutates the given path\n    function mutate(child,mutation_rate,start,target){\n        var random_no=Math.random();\n        if((random_no*100)-mutation_rate<0){\n            var temp_child=new path(start,target)\n            var temp_path=child.path\n            var random_index=getRndInteger(0,temp_path.length);\n            var temp_path=temp_path.slice(0,random_index);\n            var temp=child.path[random_index];\n            var temp_visited={};\n            var keep_original=false;\n            var target_reacher=child.path[child.path.length-1][0]===target[0] && child.path[child.path.length-1][1]===target[1];\n            if(target_reacher){\n                var random_index_two_steps_from_target=random_index+2<child.path.length;\n                if(random_index_two_steps_from_target){\n                    random_index=getRndInteger(random_index+1,child.path.length);\n                }else{\n                    random_index=child.path.length-1;\n                }\n                var temp_target=child.path[random_index];\n            }else{\n                var temp_target=target;\n            }\n            temp_path.forEach(each=>{\n                temp_visited[(each[0]+1)+','+each[1]]=true;\n            });\n            while(temp[0]!=temp_target[0] || temp[1]!=temp_target[1]){\n                temp_path.push(temp);\n                var temp_neighbours=get_neighbours(temp[0],temp[1],temp_visited);\n                if(temp_neighbours.length===0){\n                    keep_original=true;\n                    break\n                };\n                var temp_next_index=getRndInteger(0,temp_neighbours.length);\n                var temp_next=temp_neighbours[temp_next_index];\n                temp=temp_next;\n            };\n            temp_path.push(temp);\n            if(target_reacher){\n                temp_path=temp_path.concat(child.path.slice(random_index,child.path.length))\n            };\n            if(keep_original){\n                temp_path=child.path;\n            };\n            var temp_child=new path(start, target)\n            temp_child.path=temp_path;\n            temp_child.fitness=get_fitness(temp_path,target)\n            return temp_child\n        };\n        return child;\n    };\n    var start=[x,y]\n    var population=document.getElementById(\"genetic_algo_population\").value;\n    var mutation_rate=document.getElementById(\"genetic_algo_mutation_rate\").value;\n    if(population==\"\" || mutation_rate==\"\"){alert('Enter population and mutation rate');return}\n    var current_generation=[];\n    for(var i=0;i<population;i++){\n        current_generation.push(new path(start,target));\n    };\n    var genetic_algorithm_interval=setInterval(() => {\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\n            clearInterval(genetic_algorithm_interval);\n            refresh();\n            return;\n        };\n        var total_fitness=0;\n        var max_fitness=0;\n        var max_fitness_index;\n        for(var i=0;i<current_generation.length;i++){\n            if(current_generation[i].fitness>max_fitness){\n                max_fitness=current_generation[i].fitness;\n                max_fitness_index=i;\n            };\n            total_fitness+=current_generation[i].fitness;\n        };\n        var max_fitness_path=current_generation[max_fitness_index].path;\n        current_generation.forEach(each=>{\n            each.prob=each.fitness/total_fitness;\n        });\n        if(max_fitness==Infinity){\n            genetic_algorithm(no_rows,no_columns);\n            return;\n        };\n        display(max_fitness_path);\n        var temp_generation=[]\n        for(var i=0;i<population;i++){\n            var parent1=get_parent_according_to_prob(current_generation);\n            var parent2=get_parent_according_to_prob(current_generation);\n            var temp=crossover2(parent1,parent2,start,target);\n            var temp=mutate(temp,mutation_rate,start,target);\n            temp_generation.push(temp);\n        };\n        current_generation=temp_generation;\n    },10)\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}