{"ast":null,"code":"export default function BFS(no_rows, no_columns) {\n  const grids = Array.from(document.getElementsByClassName('grid'));\n  var x, y;\n  var found_start = false;\n  var target = [];\n  var found_target = false;\n  var i = 0;\n  //finds start and target grid\n  grids.forEach(grid => {\n    if (grid.classList.contains('start')) {\n      y = Math.floor(i / no_columns) + 1;\n      x = i % no_columns + 1;\n      found_start = true;\n    } else if (grid.classList.contains('target')) {\n      target.push(i % no_columns + 1);\n      target.push(Math.floor(i / no_columns) + 1);\n      found_target = true;\n    }\n    ;\n    i++;\n  });\n  //checks if start and target grid is selected\n  if (!found_start || !found_target) {\n    alert('choose target and start grid');\n    return;\n  }\n  ;\n  //gets all the non active ,non visited neighbours\n  function get_neighbours(x, y, visited) {\n    var neighbours = [];\n    var index = (y - 1) * no_columns + (x - 1);\n    visited[x + ',' + y] = true;\n    //top neighbour\n    if (y - 1 > 0 && !grids[index - no_columns].classList.contains('obstacle') && visited[x + ',' + (y - 1)] === undefined) {\n      neighbours.push([x, y - 1]);\n      visited[x + ',' + (y - 1)] = true;\n    }\n    ;\n    //right neighbour\n    if (x + 1 <= no_columns && !grids[index + 1].classList.contains('obstacle') && visited[x + 1 + ',' + y] === undefined) {\n      neighbours.push([x + 1, y]);\n      visited[x + 1 + ',' + y] = true;\n    }\n    ;\n    //bottom neighbour\n    if (y + 1 <= no_rows && !grids[index + no_columns].classList.contains('obstacle') && visited[x + ',' + (y + 1)] === undefined) {\n      neighbours.push([x, y + 1]);\n      visited[x + ',' + (y + 1)] = true;\n    }\n    ;\n    //left neighbour\n    if (x - 1 > 0 && !grids[index - 1].classList.contains('obstacle') && visited[x - 1 + ',' + y] === undefined) {\n      neighbours.push([x - 1, y]);\n      visited[x - 1 + ',' + y] = true;\n    }\n    ;\n    return neighbours;\n  }\n  ;\n  var start = [x, y];\n  found_target = false;\n  var visited = {};\n  var parent = {};\n  var temp, neighbours;\n  var queue = [[x, y]];\n  var intervalId = null;\n  intervalId = setInterval(() => {\n    if (document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML == \"false\") {\n      //stop the algorithms when stop btn is clicked\n      clearInterval(intervalId);\n      return;\n    }\n    ;\n    if (queue.length <= 0 || found_target) {\n      clearInterval(intervalId);\n    }\n    ;\n    if (x === target[0] && y === target[1]) {\n      found_target = true;\n    }\n    ;\n    if (!found_target) {\n      //continue until target is found do this\n      //dequeue from the queue\n      temp = queue.pop();\n      x = temp[0];\n      y = temp[1];\n      neighbours = get_neighbours(x, y, visited);\n      //add nearest parent to the neighbour and add it to the queue\n      neighbours.forEach(neighbour => {\n        queue.splice(0, 0, neighbour);\n        parent[neighbour[0] + ',' + neighbour[1]] = [x, y];\n      });\n      //show the grid as seen if the grid is not the start or the target\n      if (!grids[(y - 1) * no_columns + (x - 1)].classList.contains('start') && !grids[(y - 1) * no_columns + (x - 1)].classList.contains('target')) {\n        grids[(y - 1) * no_columns + (x - 1)].classList.add('seen');\n      }\n      ;\n    } else {\n      // do this if target is found\n      while (!(x === start[0] && y === start[1])) {\n        if (!grids[(y - 1) * no_columns + (x - 1)].classList.contains('start') && !grids[(y - 1) * no_columns + (x - 1)].classList.contains('target')) {\n          grids[(y - 1) * no_columns + (x - 1)].classList.add('path');\n        }\n        ;\n        temp = parent[x + ',' + y];\n        x = temp[0];\n        y = temp[1];\n      }\n      ;\n    }\n    ;\n  }, 25);\n}\n_c = BFS;\n;\nvar _c;\n$RefreshReg$(_c, \"BFS\");","map":{"version":3,"names":["BFS","no_rows","no_columns","grids","Array","from","document","getElementsByClassName","x","y","found_start","target","found_target","i","forEach","grid","classList","contains","Math","floor","push","alert","get_neighbours","visited","neighbours","index","undefined","start","parent","temp","queue","intervalId","setInterval","getElementById","innerHTML","clearInterval","length","pop","neighbour","splice","add","_c","$RefreshReg$"],"sources":["/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/BFS.js"],"sourcesContent":["export default function BFS(no_rows,no_columns){\n    const grids=Array.from(document.getElementsByClassName('grid'));\n    var x,y;\n    var found_start=false;\n    var target=[]\n    var found_target=false;\n    var i=0;\n    //finds start and target grid\n    grids.forEach(grid=>{\n        if(grid.classList.contains('start')){\n            y=Math.floor(i/no_columns)+1;\n            x=(i%no_columns)+1;\n            found_start=true;\n        }else if(grid.classList.contains('target')){\n            target.push((i%no_columns)+1);\n            target.push(Math.floor(i/no_columns)+1);\n            found_target=true;\n        };\n        i++;\n    });\n    //checks if start and target grid is selected\n    if(!found_start || !found_target){\n        alert('choose target and start grid');\n        return\n    };\n    //gets all the non active ,non visited neighbours\n    function get_neighbours(x,y,visited){\n        var neighbours=[];\n        var index=((y-1)*no_columns)+(x-1);\n        visited[x+','+y]=true;\n        //top neighbour\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle') && visited[x+','+(y-1)]===undefined){\n            neighbours.push([x,(y-1)]);\n            visited[x+','+(y-1)]=true;\n        };\n        //right neighbour\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle') && visited[(x+1)+','+y]===undefined){\n            neighbours.push([(x+1),y]);\n            visited[(x+1)+','+y]=true;\n        };\n        //bottom neighbour\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle') && visited[x+','+(y+1)]===undefined){\n            neighbours.push([x,(y+1)]);\n            visited[x+','+(y+1)]=true;\n        };\n        //left neighbour\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle') && visited[(x-1)+','+y]===undefined){\n            neighbours.push([(x-1),y]);\n            visited[(x-1)+','+y]=true;\n        };\n        return neighbours;\n    };\n    var start=[x,y]\n    found_target=false;\n    var visited={};\n    var parent={};\n    var temp,neighbours;\n    var queue=[[x,y]];\n    var intervalId=null;\n    intervalId=setInterval(()=>{\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\n            //stop the algorithms when stop btn is clicked\n            clearInterval(intervalId);\n            return;\n        };\n        if(queue.length<=0 || found_target){clearInterval(intervalId);};\n        if(x===target[0] && y===target[1]){found_target=true;};\n        if(!found_target){//continue until target is found do this\n            //dequeue from the queue\n            temp=queue.pop();\n            x=temp[0];\n            y=temp[1];\n            neighbours=get_neighbours(x,y,visited);\n            //add nearest parent to the neighbour and add it to the queue\n            neighbours.forEach(neighbour=>{\n                queue.splice(0,0,neighbour);\n                parent[neighbour[0]+','+neighbour[1]]=[x,y]\n            });\n            //show the grid as seen if the grid is not the start or the target\n            if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start')\n                && !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\n                grids[((y-1)*no_columns)+(x-1)].classList.add('seen');\n            };\n        }else{// do this if target is found\n            while(!(x===start[0] && y===start[1])){\n                if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start') && \n                    !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\n                        grids[((y-1)*no_columns)+(x-1)].classList.add('path');\n                };\n                temp=parent[x+','+y];\n                x=temp[0];\n                y=temp[1];\n            };\n        };\n    },25);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}