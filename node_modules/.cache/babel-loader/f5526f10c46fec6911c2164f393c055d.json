{"ast":null,"code":"export default function dijsktra(no_rows, no_columns) {\n  const grids = Array.from(document.getElementsByClassName('grid'));\n  let x, y;\n  var found_start = false;\n  let target = [];\n  var found_target = false;\n  var i = 0;\n  //finds start and target grid\n  grids.forEach(grid => {\n    if (grid.classList.contains('start')) {\n      y = Math.floor(i / no_columns) + 1;\n      x = i % no_columns + 1;\n      found_start = true;\n    } else if (grid.classList.contains('target')) {\n      target.push(i % no_columns + 1);\n      target.push(Math.floor(i / no_columns) + 1);\n      found_target = true;\n    }\n    ;\n    i++;\n  });\n  //checks if start and target grid is selected\n  if (!found_start || !found_target) {\n    alert('choose target and start grid');\n    return;\n  }\n  ;\n  //gets all the non active ,non visited neighbours\n  //gets all the non active ,non visited neighbours\n  function get_neighbours(x, y) {\n    var neighbours = [];\n    var index = (y - 1) * no_columns + (x - 1);\n    //top neighbour\n    if (y - 1 > 0 && !grids[index - no_columns].classList.contains('obstacle')) {\n      neighbours.push([x, y - 1]);\n    }\n    ;\n    //right neighbour\n    if (x + 1 <= no_columns && !grids[index + 1].classList.contains('obstacle')) {\n      neighbours.push([x + 1, y]);\n    }\n    ;\n    //bottom neighbour\n    if (y + 1 <= no_rows && !grids[index + no_columns].classList.contains('obstacle')) {\n      neighbours.push([x, y + 1]);\n    }\n    ;\n    //left neighbour\n    if (x - 1 > 0 && !grids[index - 1].classList.contains('obstacle')) {\n      neighbours.push([x - 1, y]);\n    }\n    ;\n    return neighbours;\n  }\n  ;\n  var j = 1;\n  var k = 1;\n  var active_grids = [];\n  //puts all the active grid to the array gids\n  grids.forEach(grid => {\n    if (!grid.classList.contains('obstacle')) {\n      active_grids.push([j, k]);\n    }\n    ;\n    if (j === no_columns) {\n      k++;\n      j = 1;\n    } else {\n      j++;\n    }\n    ;\n  });\n  let dist = {};\n  //dist from start of all the grids is infinity \n  active_grids.forEach(each => {\n    dist[each[0] + ',' + each[1]] = 999999;\n  });\n  //dist of start from start is 0\n  dist[x + ',' + y] = 0;\n  var start = [x, y];\n  var parent = {};\n  let neighbours, min;\n  let current, z, temp;\n  var keep_looping = true;\n  var intervalId = null;\n  intervalId = setInterval(() => {\n    if (document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML == \"false\") {\n      //stops the algorithm if stop btn is clicked\n      clearInterval(intervalId);\n      return;\n    }\n    ;\n    if (active_grids.length <= 0 || !keep_looping) {\n      clearInterval(intervalId);\n    }\n    min = 99999;\n    for (var i = 0; i < active_grids.length; i++) {\n      temp = dist[active_grids[i][0] + ',' + active_grids[i][1]];\n      if (min > temp) {\n        min = temp;\n        z = i;\n      }\n      ;\n    }\n    ;\n    current = active_grids[z];\n    //removes current form active_grids\n    active_grids.splice(z, 1);\n    neighbours = get_neighbours(current[0], current[1]);\n    neighbours.forEach(neighbour => {\n      //adds best parent to the neighbour\n      if (dist[current[0] + ',' + current[1]] + 1 < dist[neighbour[0] + ',' + neighbour[1]]) {\n        dist[neighbour[0] + ',' + neighbour[1]] = dist[current[0] + ',' + current[1]] + 1;\n        parent[neighbour[0] + ',' + neighbour[1]] = [current[0], current[1]];\n      }\n      //checks if the the target is reached\n      if (neighbour[0] === target[0] && neighbour[1] === target[1]) {\n        x = neighbour[0];\n        y = neighbour[1];\n        keep_looping = false;\n      }\n      ;\n      //shows the grid is visited\n      if (!grids[(neighbour[1] - 1) * no_columns + (neighbour[0] - 1)].classList.contains('start') && !grids[(neighbour[1] - 1) * no_columns + (neighbour[0] - 1)].classList.contains('target')) {\n        grids[(neighbour[1] - 1) * no_columns + (neighbour[0] - 1)].classList.add('seen');\n        grids[(neighbour[1] - 1) * no_columns + (neighbour[0] - 1)].innerHTML = dist[neighbour[0] + \",\" + neighbour[1]];\n      }\n      ;\n    });\n    if (!keep_looping) {\n      //display the final path \n      while (!(x === start[0] && y === start[1])) {\n        if (!grids[(y - 1) * no_columns + (x - 1)].classList.contains('start') && !grids[(y - 1) * no_columns + (x - 1)].classList.contains('target')) {\n          grids[(y - 1) * no_columns + (x - 1)].classList.add('path');\n        }\n        ;\n        temp = parent[x + ',' + y];\n        x = temp[0];\n        y = temp[1];\n      }\n      ;\n    }\n  }, 25);\n}\n;","map":{"version":3,"names":["dijsktra","no_rows","no_columns","grids","Array","from","document","getElementsByClassName","x","y","found_start","target","found_target","i","forEach","grid","classList","contains","Math","floor","push","alert","get_neighbours","neighbours","index","j","k","active_grids","dist","each","start","parent","min","current","z","temp","keep_looping","intervalId","setInterval","getElementById","innerHTML","clearInterval","length","splice","neighbour","add"],"sources":["/Users/sauravthakur/Desktop/Github/path_algo_visualiser/src/algorithms/dijskra.js"],"sourcesContent":["export default function dijsktra(no_rows,no_columns){\n    const grids=Array.from(document.getElementsByClassName('grid'));\n    let x,y;\n    var found_start=false;\n    let target=[]\n    var found_target=false;\n    var i=0;\n    //finds start and target grid\n    grids.forEach(grid=>{\n        if(grid.classList.contains('start')){\n            y=Math.floor(i/no_columns)+1;\n            x=(i%no_columns)+1;\n            found_start=true;\n        }else if(grid.classList.contains('target')){\n            target.push((i%no_columns)+1);\n            target.push(Math.floor(i/no_columns)+1);\n            found_target=true;\n        };\n        i++;\n    });\n    //checks if start and target grid is selected\n    if(!found_start || !found_target){\n        alert('choose target and start grid');\n        return\n    };\n    //gets all the non active ,non visited neighbours\n    //gets all the non active ,non visited neighbours\n    function get_neighbours(x,y){\n        var neighbours=[];\n        var index=((y-1)*no_columns)+(x-1);\n        //top neighbour\n        if(y-1>0 && !grids[index-no_columns].classList.contains('obstacle')){\n            neighbours.push([x,(y-1)]);\n        };\n        //right neighbour\n        if(x+1<=no_columns && !grids[index+1].classList.contains('obstacle')){\n            neighbours.push([(x+1),y]);\n        };\n        //bottom neighbour\n        if(y+1<=no_rows && !grids[index+no_columns].classList.contains('obstacle')){\n            neighbours.push([x,(y+1)]);\n        };\n        //left neighbour\n        if(x-1>0 && !grids[index-1].classList.contains('obstacle')){\n            neighbours.push([(x-1),y]);\n        };\n        return neighbours;\n    };\n    var j=1;\n    var k=1;\n    var active_grids=[]\n    //puts all the active grid to the array gids\n    grids.forEach(grid=>{\n        if(!grid.classList.contains('obstacle')){\n            active_grids.push([j,k]);\n        };\n        if(j===no_columns){\n            k++;\n            j=1;\n        }else{\n            j++;\n        };\n    });\n    let dist={};\n    //dist from start of all the grids is infinity \n    active_grids.forEach(each=>{\n        dist[each[0]+','+each[1]]=999999;\n    });\n    //dist of start from start is 0\n    dist[x+','+y]=0;\n    var start=[x,y]\n    var parent={};\n    let neighbours,min\n    let current,z,temp;\n    var keep_looping=true;\n    var intervalId=null;\n    intervalId=setInterval(()=>{\n        if(document.getElementById(\"maze_control_varaible_continue_searching\").innerHTML==\"false\"){\n            //stops the algorithm if stop btn is clicked\n            clearInterval(intervalId);\n            return;\n        };\n        if(active_grids.length<=0 || !keep_looping){clearInterval(intervalId);}\n        min=99999;\n        for(var i=0;i<active_grids.length;i++){\n            temp=dist[active_grids[i][0]+','+active_grids[i][1]]\n            if(min>temp){\n                min=temp;\n                z=i;\n            };\n        };\n        current=active_grids[z];\n        //removes current form active_grids\n        active_grids.splice(z,1);\n        neighbours=get_neighbours(current[0],current[1]);\n        neighbours.forEach(neighbour=>{\n            //adds best parent to the neighbour\n            if(dist[current[0]+','+current[1]]+1<dist[neighbour[0]+','+neighbour[1]]){\n                dist[neighbour[0]+','+neighbour[1]]=dist[current[0]+','+current[1]]+1;\n                parent[neighbour[0]+','+neighbour[1]]=[current[0],current[1]]\n            }\n            //checks if the the target is reached\n            if(neighbour[0]===target[0] && neighbour[1]===target[1]){\n                x=neighbour[0];\n                y=neighbour[1];\n                keep_looping=false\n            };\n            //shows the grid is visited\n            if(!grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('start')\n                && !grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.contains('target')){\n                    grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].classList.add('seen');\n                    grids[((neighbour[1]-1)*no_columns)+(neighbour[0]-1)].innerHTML=dist[neighbour[0]+\",\"+neighbour[1]]\n            };\n        })\n        if(!keep_looping){//display the final path \n            while(!(x===start[0] && y===start[1])){\n                if(!grids[((y-1)*no_columns)+(x-1)].classList.contains('start') && \n                    !grids[((y-1)*no_columns)+(x-1)].classList.contains('target')){\n                        grids[((y-1)*no_columns)+(x-1)].classList.add('path');\n                };\n                temp=parent[x+','+y];\n                x=temp[0];\n                y=temp[1];\n            };\n        }\n    }, 25);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}